<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Gem Slap</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { width: 100%; height: 100%; overflow: hidden; background: #000; position: fixed; top: 0; left: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif; color: #fff; touch-action: none; user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; }
        .game-wrap { position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 100%; max-width: 480px; height: 100%; background: #050508; overflow: hidden; }
        @media (min-width: 520px) and (min-height: 600px) { .game-wrap { top: 50%; transform: translate(-50%, -50%); height: 90%; max-height: 850px; border-radius: 1.2rem; border: 1px solid rgba(255,255,255,0.06); } }

        .header { position: absolute; top: 0; left: 0; right: 0; height: 52px; padding-top: env(safe-area-inset-top, 0px); z-index: 100; display: flex; align-items: center; justify-content: space-between; padding-left: max(12px, env(safe-area-inset-left, 0px)); padding-right: max(12px, env(safe-area-inset-right, 0px)); background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); }
        .h-section { display: flex; flex-direction: column; min-width: 50px; }
        .h-section.left { align-items: flex-start; }
        .h-section.center { align-items: center; flex: 1; }
        .h-section.right { align-items: flex-end; }
        .h-val { font-size: 0.9rem; font-weight: 400; font-variant-numeric: tabular-nums; }
        .h-val .orbs-low { color: #F07B18; }
        .h-val .orbs-critical { color: #C41E3A; animation: orb-warn 0.6s ease-in-out infinite alternate; }
        @keyframes orb-warn { 0% { opacity: 0.7; } 100% { opacity: 1; } }

        /* ── IMPROVED: header sub-labels ── */
        .h-lbl { font-size: 0.52rem; letter-spacing: 0.08em; text-transform: uppercase; opacity: 0.45; }



        /* ── GEM SLAP wordmark in header ── */
        .gs-logo {
            font-size: clamp(1.05rem, 4.6vw, 1.28rem); font-weight: 800;
            letter-spacing: 0.18em; line-height: 1; white-space: nowrap;
            background: linear-gradient(120deg, #A8F7F4 0%, #B3C6FF 35%, #D4A7FF 65%, #FFA7D4 100%);
            background-size: 250% 250%;
            animation: gem-grad 5s ease infinite;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 6px rgba(192,132,252,0.35));
            pointer-events: none;
        }

        /* ── IMPROVED: tier pill ── */
        .tier-pill { font-size: 0.7rem; font-weight: 600; letter-spacing: 0.07em; padding: 0.15rem 0.45rem; border-radius: 1rem; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); color: rgba(255,255,255,0.25); }
        .tier-pill.bronze { color: #7EC8F0; background: rgba(77,168,218,0.1); border-color: rgba(77,168,218,0.2); }
        .tier-pill.silver { color: #4ECDC4; background: rgba(78,205,196,0.1); border-color: rgba(78,205,196,0.2); }
        .tier-pill.gold { color: #F9DB6D; background: rgba(249,219,109,0.1); border-color: rgba(249,219,109,0.2); }

        .prog-bar { position: absolute; top: calc(52px + env(safe-area-inset-top, 0px)); left: 0; right: 0; height: 2px; background: rgba(255,255,255,0.04); z-index: 100; }
        .prog-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #1B6B9C, #4DA8DA, #8EEAF4); transition: width 0.3s ease-out; }

        #canvas { position: absolute; }

        .footer { position: absolute; bottom: 0; left: 0; right: 0; height: calc(36px + env(safe-area-inset-bottom, 0px)); display: flex; align-items: center; justify-content: center; gap: 6px; z-index: 100; }
        .footer-timer { position: absolute; left: 12px; bottom: calc(env(safe-area-inset-bottom, 0px) + 8px); font-size: 0.9rem; font-weight: 400; font-variant-numeric: tabular-nums; color: rgba(255,255,255,0.5); line-height: 1; pointer-events: none; }
        .beat-dot { width: 4px; height: 4px; border-radius: 50%; background: rgba(255,255,255,0.15); transition: all 0.06s ease; }
        .beat-dot.active { background: rgba(255,255,255,0.7); transform: scale(1.4); }
        .mute-btn { position: absolute; right: 12px; bottom: calc(env(safe-area-inset-bottom, 0px) + 1px); width: 34px; height: 34px; border-radius: 8px; background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1); color: rgba(255,255,255,0.5); font-size: 0.82rem; cursor: pointer; z-index: 101; display: flex; align-items: center; justify-content: center; }
        .mute-btn:hover { background: rgba(255,255,255,0.1); }
        .mute-btn.muted { opacity: 0.3; }

        .pop { position: absolute; pointer-events: none; font-size: 0.65rem; font-weight: 600; letter-spacing: 0.08em; text-transform: uppercase; animation: pop-up 0.45s ease-out forwards; z-index: 200; }
        @keyframes pop-up { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); } 15% { opacity: 1; transform: translate(-50%, -50%) scale(1); } 100% { opacity: 0; transform: translate(-50%, -65%); } }
        .pop.perfect { color: #F9DB6D; }
        .pop.great { color: #4ECDC4; }
        .pop.good { color: #7EC8F0; }
        .pop.miss { color: rgba(255,255,255,0.2); }
        .pop.scatter { font-size: 0.7rem !important; text-shadow: 0 0 8px currentColor; animation: pop-up-scatter 0.5s ease-out forwards; }
        @keyframes pop-up-scatter { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.4); } 12% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); } 25% { transform: translate(-50%, -53%) scale(1.0); } 100% { opacity: 0; transform: translate(-50%, -70%); } }

        .pop.crystal-break { color: #7EC8F0; font-size: 0.8rem !important; text-shadow: 0 0 12px rgba(77,168,218,0.6); animation: crystal-pop 0.6s ease-out forwards; }
        .pop.crystal-clear { color: #D6F0FF; font-size: 1.1rem !important; text-shadow: 0 0 20px rgba(126,224,240,0.7); animation: crystal-pop 0.8s ease-out forwards; }
        @keyframes crystal-pop { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); } 15% { opacity: 1; transform: translate(-50%, -50%) scale(1.3); } 30% { transform: translate(-50%, -55%) scale(1.0); } 100% { opacity: 0; transform: translate(-50%, -80%); } }

        /* ── Countdown sequence ── */
        .cd-wrap {
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 300; pointer-events: none;
            animation: cd-wrap-in 0.4s ease-out forwards;
        }
        .cd-wrap.fade-out { animation: cd-wrap-out 0.45s ease-in forwards; }
        @keyframes cd-wrap-in  { from { opacity: 0; } to { opacity: 1; } }
        @keyframes cd-wrap-out { from { opacity: 1; } to { opacity: 0; } }

        /* Frosted glass panel — sits behind the level label + name only */
        .cd-panel {
            display: flex; flex-direction: column; align-items: center;
            padding: 1.1rem 2.2rem 1.2rem;
            margin-bottom: 1.8rem;
            background: rgba(4, 3, 12, 0.68);
            backdrop-filter: blur(28px); -webkit-backdrop-filter: blur(28px);
            border-radius: 1.2rem;
            border: 1px solid rgba(255,255,255,0.07);
            /* Prismatic top accent matching the logo */
            box-shadow: inset 0 1px 0 rgba(192,132,252,0.18),
                        0 8px 32px rgba(0,0,0,0.35);
        }
        .cd-level-num {
            font-size: 0.78rem; font-weight: 600; letter-spacing: 0.22em;
            text-transform: uppercase; color: rgba(255,255,255,0.55);
            margin-bottom: 0.3rem;
        }
        .cd-level-name {
            font-size: clamp(1.3rem, 6vw, 1.9rem); font-weight: 800;
            letter-spacing: 0.12em; line-height: 1.1; text-align: center;
            white-space: nowrap;
            background: linear-gradient(120deg, #A8F7F4 0%, #B3C6FF 35%, #D4A7FF 65%, #FFA7D4 100%);
            background-size: 250% 250%;
            animation: gem-grad 5s ease infinite;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px rgba(192,132,252,0.3));
        }
        .cd-number {
            font-size: 4.5rem; font-weight: 100; line-height: 1;
            letter-spacing: 0.05em; color: rgba(255,255,255,0.9);
            animation: cd-num-pop 0.5s cubic-bezier(0.22,1,0.36,1) forwards;
            text-shadow: 0 0 30px rgba(255,255,255,0.2);
            min-height: 5rem; display: flex; align-items: center; justify-content: center;
        }
        .cd-number.c1 { /* aqua */
            background: linear-gradient(135deg, #A8F7F4, #7EC8F0);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 16px rgba(127,244,240,0.5));
        }
        .cd-number.c2 { /* violet */
            background: linear-gradient(135deg, #D4A7FF, #B3C6FF);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 16px rgba(192,132,252,0.5));
        }
        .cd-number.c3 { /* rose */
            background: linear-gradient(135deg, #FFA7D4, #D4A7FF);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 16px rgba(255,167,212,0.5));
        }

        @keyframes cd-num-pop {
            0%   { opacity: 0; transform: scale(1.6); }
            18%  { opacity: 1; transform: scale(0.95); }
            45%  { transform: scale(1.0); }
            80%  { opacity: 1; }
            100% { opacity: 0; transform: scale(0.82); }
        }

        .overlay { position: absolute; inset: 0; z-index: 500; transition: opacity 0.5s ease, visibility 0.5s; }
        .overlay.hidden { opacity: 0; visibility: hidden; pointer-events: none; }

        #start-screen {
            display: flex; align-items: center; justify-content: center; overflow: hidden;
        }
        #intro-canvas { position: absolute; inset: 0; width: 100%; height: 100%; }

        .intro-z {
            position: relative; z-index: 1;
            display: flex; flex-direction: column; align-items: center;
            justify-content: space-between;
            width: 100%; height: 100%;
            padding: max(9vh, 2.2rem) 1.5rem max(6vh, 1.8rem);
            pointer-events: none;
        }
        .intro-top { display: flex; flex-direction: column; align-items: center; }
        .intro-mid  { flex: 1; }
        .intro-bottom {
            display: flex; flex-direction: column; align-items: center;
            width: 100%; max-width: 320px; gap: 0.5rem;
        }

        .title {
            font-size: clamp(1.8rem, 9.2vw, 3.2rem); font-weight: 800;
            letter-spacing: 0.22em; line-height: 1; white-space: nowrap;
            margin-bottom: 0.6rem;
            background: linear-gradient(120deg, #A8F7F4 0%, #B3C6FF 35%, #D4A7FF 65%, #FFA7D4 100%);
            background-size: 250% 250%;
            animation: gem-grad 5s ease infinite;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 18px rgba(192,132,252,0.3));
        }
        @keyframes gem-grad { 0%, 100% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } }

        .tagline {
            font-size: 0.63rem; letter-spacing: 0.24em; margin-left: 0.24em;
            color: rgba(255,255,255,0.3); text-transform: uppercase; font-weight: 300;
        }

        .tut-hint {
            position: absolute;
            top: 52%;          /* just below sceneY=44% + gem/orb height */
            left: 0; right: 0;
            font-size: 0.7rem; letter-spacing: 0.16em; text-transform: uppercase; font-weight: 500;
            opacity: 0; transition: opacity 0.35s ease, transform 0.35s ease;
            transform: translateY(5px); text-align: center;
        }
        .tut-hint.show { opacity: 1; transform: translateY(0); }
        .tut-hint.tap-state   { color: rgba(160,80,255,0.9);  text-shadow: 0 0 14px rgba(160,80,255,0.35); }
        .tut-hint.shatter-state { color: rgba(127,244,240,0.9); text-shadow: 0 0 14px rgba(127,244,240,0.35); }

        /* Wrapper carries all animations — button itself is static so iOS fires on first tap */
        .play-btn-wrap {
            width: 100%; pointer-events: auto;
            animation: btn-lift 2.4s ease-in-out infinite;
            will-change: transform;
            border-radius: 3rem;
            box-shadow: 0 4px 28px rgba(192,132,252,0.45), 0 0 60px rgba(192,132,252,0.15);
        }
        @keyframes btn-lift {
            0%, 100% { transform: translateY(0); }
            50%       { transform: translateY(-3px); }
        }
        .play-btn {
            pointer-events: auto; cursor: pointer; width: 100%;
            background: linear-gradient(120deg, #A8F7F4 0%, #B3C6FF 35%, #D4A7FF 65%, #FFA7D4 100%);
            background-size: 250% 250%;
            animation: gem-grad 5s ease infinite;
            border: none; border-radius: 3rem;
            color: rgba(20,10,40,0.82);
            font-size: 0.9rem; font-weight: 800; letter-spacing: 0.3em; text-transform: uppercase;
            padding: 1.05rem 0;
            box-shadow: inset 0 1px 0 rgba(255,255,255,0.5);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation; /* tell iOS: tap only, no gesture evaluation delay */
            display: block;
        }
        .play-btn:active { opacity: 0.88; }
        .intro-tap-hint {
            font-size: 0.44rem; letter-spacing: 0.15em; text-transform: uppercase;
            color: rgba(255,255,255,0.18); pointer-events: none;
        }

        /* ═══════════════════════════════════════════════════
           FLOATING END CARD — fully improved typography
        ═══════════════════════════════════════════════════ */
        .end-float {
            position: absolute;
            bottom: 0; left: 0; right: 0;
            z-index: 200;
            display: flex; justify-content: center;
            padding: 0 0.5rem;
            padding-bottom: max(0.4rem, env(safe-area-inset-bottom, 0px));
            transform: translateY(110%);
            transition: transform 0.55s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: none;
        }
        .end-float.show {
            transform: translateY(0);
            pointer-events: auto;
        }
        .ef-card {
            width: 100%; max-width: 380px;
            background: rgba(5,5,10,0.92);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.06);
            border-bottom: none;
            border-radius: 1.2rem 1.2rem 0 0;
            padding: 1.2rem 1.4rem 1rem;
            display: flex; flex-direction: column; align-items: center;
            position: relative; overflow: hidden;
        }
        /* Top accent glow bar */
        .ef-card::before {
            content: ''; position: absolute;
            top: 0; left: 10%; right: 10%; height: 2px;
            border-radius: 2px;
        }
        .ef-card.tier-gold::before { background: #F9DB6D; box-shadow: 0 0 24px rgba(249,219,109,0.5); }
        .ef-card.tier-silver::before { background: #4ECDC4; box-shadow: 0 0 18px rgba(78,205,196,0.4); }
        .ef-card.tier-bronze::before { background: #7EC8F0; box-shadow: 0 0 14px rgba(126,200,240,0.3); }
        .ef-card.tier-none::before { background: rgba(255,255,255,0.08); }
        /* Fail state — very dim warm bar, no glow, not harsh */
        .ef-card.tier-fail::before { background: rgba(180,80,60,0.35); box-shadow: none; }

        /* ── Fail-specific elements (hidden in win state) ── */
        .ef-fail-crystals {
            display: none;
            flex-direction: column; align-items: center;
            margin-bottom: 0.6rem;
        }
        .ef-card.tier-fail .ef-fail-crystals { display: flex; }
        .ef-fail-crys-val {
            font-size: 2.6rem; font-weight: 100; line-height: 1;
            font-variant-numeric: tabular-nums;
            color: rgba(255,255,255,0.25);
            margin-bottom: 0.2rem;
        }
        .ef-fail-crys-label {
            font-size: 0.5rem; letter-spacing: 0.18em; text-transform: uppercase;
            color: rgba(255,255,255,0.2);
        }
        .ef-fail-msg {
            display: none;
            font-size: 0.62rem; color: rgba(255,255,255,0.32);
            letter-spacing: 0.06em; margin-bottom: 0.85rem;
            text-align: center; line-height: 1.5;
        }
        .ef-card.tier-fail .ef-fail-msg { display: block; }

        /* Hide win-only elements in fail state */
        .ef-card.tier-fail .ef-pb   { display: none; }
        .ef-card.tier-fail .ef-hero { display: none; }

        /* ── level label in floating card ── */
        .ef-level {
            font-size: 0.86rem; letter-spacing: 0.1em; text-transform: uppercase;
            color: rgba(255,255,255,0.65); margin-bottom: 0.5rem; text-align: center; line-height: 1.3;
            font-weight: 400;
        }

        /* ── tier + time hero area — single row ── */
        .ef-hero {
            display: flex; flex-direction: row; align-items: baseline;
            gap: 0.6rem; margin-bottom: 0.7rem;
        }

        /* ── tier badge ── */
        .ef-tier-badge {
            font-size: 1.6rem; line-height: 1;
        }
        .ef-tier-badge.c-gold { filter: drop-shadow(0 0 8px rgba(249,219,109,0.5)); }
        .ef-tier-badge.c-silver { filter: drop-shadow(0 0 6px rgba(78,205,196,0.4)); }
        .ef-tier-badge.c-bronze { filter: drop-shadow(0 0 5px rgba(126,200,240,0.3)); }
        .ef-tier-badge.c-none { opacity: 0.3; }

        .ef-time {
            font-size: 1.1rem; font-weight: 200; line-height: 1;
            font-variant-numeric: tabular-nums;
            color: rgba(255,255,255,0.45);
        }

        /* ── personal best row ── */
        .ef-pb {
            font-size: 0.56rem; letter-spacing: 0.14em; text-transform: uppercase;
            color: rgba(255,255,255,0.28); margin-bottom: 0.55rem;
            display: flex; align-items: center; gap: 0.4rem;
            min-height: 1em;
        }
        .ef-pb-val { font-variant-numeric: tabular-nums; }
        .ef-pb-badge {
            font-size: 0.48rem; font-weight: 800; letter-spacing: 0.18em;
            padding: 0.12rem 0.45rem; border-radius: 1rem;
            background: linear-gradient(120deg, #A8F7F4 0%, #B3C6FF 35%, #D4A7FF 65%, #FFA7D4 100%);
            background-size: 250% 250%;
            animation: gem-grad 4s ease infinite;
            color: rgba(10,5,25,0.9);
            display: none;
        }
        .ef-pb-badge.show { display: inline-block; animation: gem-grad 4s ease infinite, pb-pop 0.5s cubic-bezier(0.22,1,0.36,1) forwards; }
        @keyframes pb-pop { 0% { transform: scale(0.5); opacity:0; } 100% { transform: scale(1); opacity:1; } }



        /* ── Buttons — side by side ── */
        .ef-btns {
            display: flex; flex-direction: row; gap: 0.5rem;
            width: 100%; max-width: 320px;
        }

        /* ── continue button ── */
        .ef-btn-continue {
            flex: 2; padding: 0.75rem 0; font-size: 0.76rem;
            font-weight: 700; letter-spacing: 0.14em; text-transform: uppercase;
            border: none; border-radius: 2rem; cursor: pointer;
            color: rgba(0,0,0,0.85);
            transition: all 0.2s ease;
        }
        .ef-btn-continue:active { transform: scale(0.97); }
        .ef-card.tier-gold .ef-btn-continue {
            background: linear-gradient(135deg, #F9DB6D, #E8C94A);
            box-shadow: 0 2px 16px rgba(249,219,109,0.3), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .ef-card.tier-gold .ef-btn-continue:active { box-shadow: 0 1px 8px rgba(249,219,109,0.2); }
        .ef-card.tier-silver .ef-btn-continue {
            background: linear-gradient(135deg, #4ECDC4, #3CB8B0);
            box-shadow: 0 2px 16px rgba(78,205,196,0.3), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .ef-card.tier-silver .ef-btn-continue:active { box-shadow: 0 1px 8px rgba(78,205,196,0.2); }
        .ef-card.tier-bronze .ef-btn-continue {
            background: linear-gradient(135deg, #7EC8F0, #5BB5E0);
            box-shadow: 0 2px 16px rgba(126,200,240,0.25), inset 0 1px 0 rgba(255,255,255,0.3);
        }
        .ef-card.tier-bronze .ef-btn-continue:active { box-shadow: 0 1px 8px rgba(126,200,240,0.15); }
        .ef-card.tier-none .ef-btn-continue {
            background: rgba(255,255,255,0.12);
            color: rgba(255,255,255,0.6);
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        /* ── retry button ── */
        .ef-btn-retry {
            flex: 1; padding: 0.75rem 0; font-size: 0.62rem;
            font-weight: 500; letter-spacing: 0.12em; text-transform: uppercase;
            border: 1px solid rgba(255,255,255,0.12); border-radius: 2rem;
            cursor: pointer; background: transparent;
            color: rgba(255,255,255,0.45);
            transition: all 0.2s ease;
        }
        .ef-btn-retry:active { transform: scale(0.97); color: rgba(255,255,255,0.6); background: rgba(255,255,255,0.04); }

        /* Fail state — hide continue, make retry fill the full width and look primary */
        .ef-card.tier-fail #ef-next  { display: none; }
        .ef-card.tier-fail .ef-btn-retry {
            flex: 1;
            background: rgba(255,255,255,0.12);
            color: rgba(255,255,255,0.85);
            border-color: rgba(255,255,255,0.18);
            box-shadow: 0 2px 12px rgba(0,0,0,0.2), inset 0 1px 0 rgba(255,255,255,0.08);
        }
        .ef-card.tier-fail .ef-btn-retry:active {
            background: rgba(255,255,255,0.16);
            color: rgba(255,255,255,0.9);
        }



        /* ═══════════════════════════════════════════════════
           FULL END SCREEN — improved throughout
        ═══════════════════════════════════════════════════ */
        #end-screen { display: flex; align-items: center; justify-content: center; }
        #end-screen::before { content: ''; position: absolute; inset: 0; background: rgba(5,5,8,0.8); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); }
        .end-card { position: relative; z-index: 1; width: calc(100% - 3rem); max-width: 300px; display: flex; flex-direction: column; align-items: center; padding: 1.6rem 1.2rem 1.4rem; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); border-radius: 1rem; }
        .end-card::before { content: ''; position: absolute; top: -1px; left: 20%; right: 20%; height: 2px; border-radius: 2px; transition: background 0.5s, box-shadow 0.5s, opacity 0.5s; }
        .end-card.tier-gold::before { background: #F9DB6D; box-shadow: 0 0 20px rgba(249,219,109,0.4), 0 0 40px rgba(249,219,109,0.15); }
        .end-card.tier-silver::before { background: #4ECDC4; box-shadow: 0 0 15px rgba(78,205,196,0.3); }
        .end-card.tier-bronze::before { background: #7EC8F0; box-shadow: 0 0 12px rgba(126,200,240,0.25); }
        .end-card.tier-none::before { background: rgba(255,255,255,0.08); }
        .end-card.tier-fail::before { opacity: 0; }

        /* ── end screen level label ── */
        .ec-level { font-size: 0.86rem; letter-spacing: 0.1em; text-transform: uppercase; opacity: 0.65; margin-bottom: 0.8rem; text-align: center; line-height: 1.3; font-weight: 400; }

        .ec-score { font-size: 3.5rem; font-weight: 100; line-height: 1; margin-bottom: 0.1rem; font-variant-numeric: tabular-nums; transition: color 0.4s; }
        .ec-score.c-gold { color: #F9DB6D; } .ec-score.c-silver { color: #4ECDC4; } .ec-score.c-bronze { color: #7EC8F0; }
        .ec-score.c-none { color: rgba(255,255,255,0.35); } .ec-score.c-fail { color: rgba(255,255,255,0.12); }

        /* ── IMPROVED: tier text in end screen ── */
        .ec-tier { font-size: 0.72rem; letter-spacing: 0.22em; text-transform: uppercase; font-weight: 700; margin-bottom: 0.15rem; }
        .ec-tier.c-gold { color: #F9DB6D; } .ec-tier.c-silver { color: #4ECDC4; } .ec-tier.c-bronze { color: #7EC8F0; }
        .ec-tier.c-none { color: rgba(255,255,255,0.2); } .ec-tier.c-fail { color: rgba(255,255,255,0.15); }

        /* ── IMPROVED: result message ── */
        .ec-msg { font-size: 0.62rem; opacity: 0.35; letter-spacing: 0.05em; margin-bottom: 1rem; }

        .ec-row { display: flex; width: 100%; margin-bottom: 1rem; background: rgba(255,255,255,0.015); border-radius: 0.5rem; border: 1px solid rgba(255,255,255,0.03); overflow: hidden; }
        .ec-cell { flex: 1; text-align: center; padding: 0.5rem 0.2rem; }
        .ec-cell + .ec-cell { border-left: 1px solid rgba(255,255,255,0.03); }

        /* ── IMPROVED: stat values and labels ── */
        .ec-val { font-size: 0.88rem; font-weight: 300; font-variant-numeric: tabular-nums; color: rgba(255,255,255,0.7); }
        .ec-val.crystal { color: #7EC8F0; }
        .ec-lbl { font-size: 0.48rem; letter-spacing: 0.07em; text-transform: uppercase; opacity: 0.3; margin-top: 0.12rem; }

        .ec-melody { display: flex; gap: 2px; flex-wrap: wrap; justify-content: center; margin-bottom: 0.5rem; max-width: 220px; min-height: 6px; }
        .ec-melody .mdot { width: 4px; height: 4px; border-radius: 50%; }
        .bass-fav { display: flex; align-items: center; justify-content: center; gap: 0.4rem; margin-bottom: 1rem; padding: 0.2rem 0.5rem; cursor: pointer; transition: all 0.2s; border: none; background: none; }
        .bass-fav .bass-name { font-size: 0.42rem; opacity: 0.2; letter-spacing: 0.06em; transition: opacity 0.2s; }
        .bass-fav .fav-heart { font-size: 0.6rem; opacity: 0.12; transition: all 0.3s ease; }
        .bass-fav.locked .fav-heart { opacity: 1; color: #F07B18; transform: scale(1.2); }
        .bass-fav.locked .bass-name { opacity: 0.45; }

        .ec-btns { display: flex; gap: 0.5rem; align-items: center; width: 100%; justify-content: center; }

        /* ── IMPROVED: general buttons — larger & more readable ── */
        .btn { padding: 0.55rem 1.1rem; font-size: 0.68rem; letter-spacing: 0.1em; text-transform: uppercase; border: 1px solid rgba(255,255,255,0.1); background: transparent; color: rgba(255,255,255,0.45); cursor: pointer; border-radius: 2rem; transition: all 0.2s; }
        .btn:hover { background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.7); }
        .btn:active { transform: scale(0.96); }
        .btn:disabled { opacity: 0.1; pointer-events: none; }

        /* ── IMPROVED: primary button ── */
        .btn.primary { padding: 0.7rem 2rem; font-size: 0.75rem; letter-spacing: 0.12em; background: linear-gradient(135deg, rgba(240,123,24,0.1), rgba(196,30,58,0.06)); border-color: rgba(240,123,24,0.18); color: rgba(255,255,255,0.85); box-shadow: 0 0 20px rgba(240,123,24,0.05); font-weight: 600; }
        .btn.primary:hover { background: linear-gradient(135deg, rgba(240,123,24,0.18), rgba(196,30,58,0.1)); box-shadow: 0 0 30px rgba(240,123,24,0.12); }

        .end-card { opacity: 0; transform: translateY(20px) scale(0.96); }
        .end-card.show { opacity: 1; transform: translateY(0) scale(1); transition: opacity 0.45s ease, transform 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
        .ec-inner { opacity: 0; }
        .ec-inner.show { opacity: 1; transition: opacity 0.35s ease; }
        .ver { position: absolute; bottom: 2px; left: 4px; font-size: 7px; opacity: 0.15; }

        /* ═══════════════════════════════════════════════════
           ACHIEVEMENT TOAST — V2 Pill Drop
        ═══════════════════════════════════════════════════ */
        #ach-toast {
            position: absolute;
            top: 50px;                         /* just below progress bar */
            left: 50%;
            transform: translateX(-50%) translateY(-140%);
            z-index: 250;
            display: flex; align-items: center; gap: 11px;
            background: rgba(5,5,10,0.95);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255,255,255,0.09);
            border-radius: 12px;
            padding: 13px 18px 13px 13px;
            pointer-events: none;
            box-shadow: 0 8px 32px rgba(0,0,0,0.55);
            white-space: nowrap;
            /* spring drop */
            transition: transform 0.5s cubic-bezier(0.34,1.56,0.64,1),
                        opacity 0.3s ease;
            opacity: 0;
            /* ensure it never overflows phone width */
            max-width: calc(100% - 32px);
        }
        /* prismatic top accent */
        #ach-toast::before {
            content: '';
            position: absolute; top: -1px; left: 15%; right: 15%; height: 1.5px;
            border-radius: 2px;
            background: linear-gradient(90deg, #8EEAF4, #B3C6FF, #D4A7FF);
            box-shadow: 0 0 8px rgba(212,167,255,0.4);
        }
        #ach-toast.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        #ach-toast.hide {
            transform: translateX(-50%) translateY(-130%) scale(0.95);
            opacity: 0;
            transition: transform 0.3s ease-in, opacity 0.25s ease-in;
        }
        .ach-toast-icon { font-size: 2rem; flex-shrink: 0; line-height: 1; }
        .ach-toast-text { display: flex; flex-direction: column; gap: 4px; min-width: 0; }
        .ach-toast-label {
            font-size: 0.58rem; letter-spacing: 0.16em; text-transform: uppercase;
            color: rgba(255,255,255,0.38); line-height: 1;
        }
        .ach-toast-name {
            font-size: 1.05rem; font-weight: 700; letter-spacing: 0.08em;
            text-transform: uppercase; color: #fff; line-height: 1.1;
        }
        .ach-toast-desc {
            font-size: 0.7rem; color: rgba(255,255,255,0.5);
            line-height: 1.35; white-space: normal;
        }

        /* ── Offline error screen ── */
        .offline-screen {
            position: absolute; inset: 0; z-index: 600;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 1rem; background: rgba(3,3,8,0.96);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            opacity: 0; pointer-events: none; transition: opacity 0.4s ease;
        }
        .offline-screen.show { opacity: 1; pointer-events: auto; }
        .offline-icon { font-size: 2.5rem; opacity: 0.4; }
        .offline-msg {
            font-size: 0.78rem; letter-spacing: 0.12em; text-transform: uppercase;
            color: rgba(255,255,255,0.45); text-align: center; line-height: 1.6;
        }
        .offline-retry {
            margin-top: 0.5rem; padding: 0.7rem 2rem;
            font-size: 0.7rem; font-weight: 700; letter-spacing: 0.18em; text-transform: uppercase;
            border: 1px solid rgba(192,132,252,0.35); border-radius: 2rem;
            background: rgba(192,132,252,0.08); color: rgba(212,167,255,0.9);
            cursor: pointer; transition: all 0.2s ease;
        }
        .offline-retry:active { transform: scale(0.96); }

        /* ══════════════════════════════════════════════
           MENU — bottom sheet, game keeps running
        ══════════════════════════════════════════════ */

        /* Small menu button — reused on intro + ef-card */
        .menu-btn-sm {
            width: 28px; height: 28px; border-radius: 8px;
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.45); font-size: 0.7rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            -webkit-tap-highlight-color: transparent;
            transition: background 0.15s; flex-shrink: 0;
        }
        .menu-btn-sm:active { background: rgba(255,255,255,0.16); }

        /* Menu button in footer (lower-right) */
        .menu-btn {
            width: 34px; height: 34px; border-radius: 8px;
            background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.5); font-size: 0.82rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            -webkit-tap-highlight-color: transparent;
            transition: background 0.15s;
        }
        .menu-btn:active { background: rgba(255,255,255,0.16); }

        .menu-overlay {
            position: absolute; inset: 0; z-index: 800;
            background: rgba(0,0,0,0.45);
            backdrop-filter: blur(3px); -webkit-backdrop-filter: blur(3px);
            opacity: 0; pointer-events: none;
            transition: opacity 0.35s ease;
        }
        .menu-overlay.show { opacity: 1; pointer-events: auto; }

        .menu-panel {
            position: absolute; left: 0; right: 0; bottom: 0;
            z-index: 801;
            height: 86%;
            background: rgba(5,4,16,0.97);
            backdrop-filter: blur(32px); -webkit-backdrop-filter: blur(32px);
            border-top: 1px solid rgba(255,255,255,0.07);
            border-radius: 1.4rem 1.4rem 0 0;
            display: flex; flex-direction: column;
            transform: translateY(100%);
            transition: transform 0.42s cubic-bezier(0.25,0.46,0.45,0.94);
            /* prismatic top accent */
            box-shadow: inset 0 1px 0 rgba(192,132,252,0.2), 0 -8px 40px rgba(0,0,0,0.6);
        }
        .menu-panel.show { transform: translateY(0); }

        .menu-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 1.1rem 1.4rem 0;
            flex-shrink: 0;
        }
        .menu-title {
            font-size: clamp(1.1rem,5vw,1.4rem); font-weight: 800; letter-spacing: 0.2em;
            background: linear-gradient(120deg,#A8F7F4 0%,#B3C6FF 35%,#D4A7FF 65%,#FFA7D4 100%);
            background-size: 250% 250%; animation: gem-grad 5s ease infinite;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .menu-close {
            width: 28px; height: 28px; border-radius: 8px;
            background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.5); font-size: 0.7rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }
        .menu-close:active { background: rgba(255,255,255,0.14); }

        .menu-tabs {
            display: flex; gap: 0; padding: 0.9rem 1.4rem 0;
            flex-shrink: 0; border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .menu-tab {
            flex: 1; padding: 0.5rem 0.3rem; font-size: 0.6rem; font-weight: 600;
            letter-spacing: 0.14em; text-transform: uppercase;
            color: rgba(255,255,255,0.3); background: transparent; border: none;
            cursor: pointer; border-bottom: 2px solid transparent;
            transition: color 0.2s, border-color 0.2s;
            -webkit-tap-highlight-color: transparent;
            margin-bottom: -1px;
        }
        .menu-tab.active {
            color: rgba(255,255,255,0.9);
            border-bottom-color: rgba(192,132,252,0.7);
        }

        .menu-content { flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch; }

        .menu-pane { padding: 1.2rem 1.4rem; display: none; }
        .menu-pane.active { display: block; }

        /* Section headers inside panes */
        .mpane-label {
            font-size: 0.48rem; letter-spacing: 0.22em; text-transform: uppercase;
            color: rgba(255,255,255,0.25); margin-bottom: 0.7rem; margin-top: 1.1rem;
        }
        .mpane-label:first-child { margin-top: 0; }

        /* Progress: level reached hero */
        .mp-level-hero {
            display: flex; align-items: baseline; gap: 0.4rem;
            margin-bottom: 1.2rem;
        }
        .mp-level-num {
            font-size: 3rem; font-weight: 100; line-height: 1;
            color: rgba(255,255,255,0.9); font-variant-numeric: tabular-nums;
        }
        .mp-level-lbl { font-size: 0.6rem; letter-spacing: 0.2em; text-transform: uppercase; color: rgba(255,255,255,0.3); }

        /* Medal grid */
        .medal-grid {
            display: grid; grid-template-columns: repeat(10, 1fr);
            gap: 5px; margin-bottom: 0.5rem;
        }
        .medal-cell {
            aspect-ratio: 1; display: flex; align-items: center; justify-content: center;
        }
        .medal-emoji {
            font-size: 0.85rem; line-height: 1; display: flex;
            align-items: center; justify-content: center;
        }
        .medal-emoji.cleared { opacity: 0.18; font-size: 0.6rem; }
        .medal-emoji.locked  { opacity: 0.07; font-size: 0.5rem; }
        .medal-batch-label {
            font-size: 0.42rem; letter-spacing: 0.14em; text-transform: uppercase;
            color: rgba(255,255,255,0.2); margin-bottom: 0.35rem; margin-top: 0.7rem;
        }
        .medal-batch-label:first-child { margin-top: 0; }

        /* Stats rows */
        .stat-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 0.8rem;
        }
        .stat-cell {
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.06);
            border-radius: 0.7rem; padding: 0.8rem 0.9rem;
        }
        .stat-val {
            font-size: 1.4rem; font-weight: 200; color: rgba(255,255,255,0.9);
            font-variant-numeric: tabular-nums; line-height: 1; margin-bottom: 0.25rem;
        }
        .stat-lbl { font-size: 0.48rem; letter-spacing: 0.14em; text-transform: uppercase; color: rgba(255,255,255,0.3); }

        /* Achievements */
        .ach-list { display: flex; flex-direction: column; gap: 0.6rem; }
        .ach-item {
            display: flex; align-items: center; gap: 0.9rem;
            padding: 0.75rem 0.9rem; border-radius: 0.8rem;
            border: 1px solid rgba(255,255,255,0.06);
            background: rgba(255,255,255,0.02);
            transition: opacity 0.3s;
        }
        .ach-item.locked { opacity: 0.4; }
        .ach-icon {
            font-size: 1.2rem; width: 2rem; text-align: center; flex-shrink: 0;
        }
        .ach-text { flex: 1; }
        .ach-name { font-size: 0.72rem; font-weight: 600; color: rgba(255,255,255,0.88); margin-bottom: 0.15rem; }
        .ach-desc { font-size: 0.54rem; letter-spacing: 0.06em; color: rgba(255,255,255,0.35); }
        .ach-check {
            font-size: 0.9rem; color: rgba(192,132,252,0.8); flex-shrink: 0;
            opacity: 0; transition: opacity 0.3s;
        }
        .ach-item:not(.locked) .ach-check { opacity: 1; }

        /* Progress bar — shown only on locked countable achievements */
        .ach-progress { margin-top: 0.4rem; display: flex; align-items: center; gap: 0.5rem; }
        .ach-progress-bar {
            flex: 1; height: 3px; border-radius: 2px;
            background: rgba(255,255,255,0.08); overflow: hidden;
        }
        .ach-progress-fill {
            height: 100%; border-radius: 2px; min-width: 2px;
            background: linear-gradient(90deg, #4DA8DA, #8EEAF4);
            transition: width 0.4s ease;
        }
        .ach-progress-label {
            font-size: 0.48rem; color: rgba(255,255,255,0.3);
            letter-spacing: 0.06em; white-space: nowrap; flex-shrink: 0;
        }

        /* Footer: level select button */
        .menu-footer {
            flex-shrink: 0; padding: 0.8rem 1.4rem;
            padding-bottom: max(0.8rem, env(safe-area-inset-bottom, 0px));
            border-top: 1px solid rgba(255,255,255,0.05);
        }
        .ls-open-btn {
            width: 100%; padding: 0.75rem; font-size: 0.66rem; font-weight: 700;
            letter-spacing: 0.14em; text-transform: uppercase;
            border: 1px solid rgba(255,255,255,0.12); border-radius: 2rem;
            background: rgba(255,255,255,0.05); color: rgba(255,255,255,0.75);
            cursor: pointer; transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }
        .ls-open-btn:active { background: rgba(255,255,255,0.1); transform: scale(0.98); }

        /* ══════════════════════════════════════════════
           LEVEL SELECT SHEET
        ══════════════════════════════════════════════ */
        .ls-overlay {
            position: absolute; inset: 0; z-index: 850;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px);
            opacity: 0; pointer-events: none; visibility: hidden;
            transition: opacity 0.35s ease;
        }
        .ls-overlay.show { opacity: 1; pointer-events: auto; visibility: visible; }

        .ls-panel {
            position: absolute; left: 0; right: 0; bottom: 0;
            z-index: 851; height: 92%;
            background: rgba(4,3,14,0.98);
            backdrop-filter: blur(32px); -webkit-backdrop-filter: blur(32px);
            border-top: 1px solid rgba(255,255,255,0.07);
            border-radius: 1.4rem 1.4rem 0 0;
            box-shadow: inset 0 1px 0 rgba(168,247,244,0.15), 0 -8px 40px rgba(0,0,0,0.6);
            display: none; flex-direction: column; /* display:none = cannot render at all */
            overflow: hidden;
            visibility: hidden;             /* belt-and-suspenders — covers any display glitch */
            transform: translateY(100%);
            transition: transform 0.42s cubic-bezier(0.25,0.46,0.45,0.94);
            pointer-events: none;
        }
        /* .animating: display:flex so transition can play, but still off-screen */
        .ls-panel.animating { display: flex; }
        /* .show: fully visible and interactive */
        .ls-panel.show { display: flex; visibility: visible; transform: translateY(0); pointer-events: auto; }

        .ls-header {
            display: flex; align-items: center; justify-content: space-between;
            padding: 1.1rem 1.4rem 0.9rem; flex-shrink: 0;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }
        .ls-title {
            font-size: 0.72rem; font-weight: 700; letter-spacing: 0.22em;
            text-transform: uppercase; color: rgba(255,255,255,0.7);
        }
        .ls-close {
            width: 28px; height: 28px; border-radius: 8px;
            background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
            color: rgba(255,255,255,0.5); font-size: 0.7rem; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }
        .ls-close:active { background: rgba(255,255,255,0.14); }

        .ls-scroll {
            flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch;
            padding: 0 1rem 1rem;
        }

        .ls-batch-label {
            position: sticky; top: 0;
            font-size: 0.44rem; letter-spacing: 0.2em; text-transform: uppercase;
            color: rgba(255,255,255,0.25);
            padding: 0.7rem 0 0.4rem;
            background: rgba(4,3,14,0.98);
            z-index: 2;
        }

        .ls-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;
            margin-bottom: 0.3rem;
        }

        .ls-card {
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.07);
            border-radius: 0.75rem; padding: 0.7rem 0.75rem 0.6rem;
            cursor: pointer; transition: background 0.15s, border-color 0.15s;
            display: flex; flex-direction: column; gap: 0.25rem;
            min-height: 78px; position: relative;
            -webkit-tap-highlight-color: transparent;
        }
        .ls-card:active { background: rgba(255,255,255,0.07); }
        .ls-card.locked { opacity: 0.28; cursor: default; }
        .ls-card-top {
            display: flex; align-items: flex-start; justify-content: space-between;
        }
        .ls-card-num {
            font-size: 0.56rem; font-weight: 600; letter-spacing: 0.1em;
            color: rgba(255,255,255,0.28); line-height: 1;
        }
        .ls-medal-icon { font-size: 0.9rem; line-height: 1; flex-shrink: 0; }
        .ls-medal-dot {
            width: 8px; height: 8px; border-radius: 2px; flex-shrink: 0;
            background: rgba(255,255,255,0.12);
        }
        .ls-medal-dot.cleared { background: rgba(255,255,255,0.12); }
        .ls-medal-dot.locked  { background: rgba(255,255,255,0.05); }

        .ls-card-name {
            font-size: 0.66rem; font-weight: 600; color: rgba(255,255,255,0.82);
            line-height: 1.25; flex: 1;
            overflow: hidden; display: -webkit-box;
            -webkit-line-clamp: 2; -webkit-box-orient: vertical;
        }
        .ls-card-name.unknown { color: rgba(255,255,255,0.25); font-style: italic; font-weight: 400; }

        .ls-card-time {
            font-size: 0.52rem; font-variant-numeric: tabular-nums;
            color: rgba(255,255,255,0.35); text-align: right; line-height: 1;
            margin-top: auto;
        }
        .ls-card-time.gold   { color: rgba(249,219,109,0.7); }
        .ls-card-time.silver { color: rgba(78,205,196,0.7); }
        .ls-card-time.bronze { color: rgba(126,200,240,0.7); }

        /* Reset at bottom of sheet */
        .ls-reset-wrap {
            padding: 1.4rem 1rem 0.5rem;
            display: flex; justify-content: center;
        }
        .ls-reset-btn {
            padding: 0.6rem 2rem; font-size: 0.54rem; font-weight: 600;
            letter-spacing: 0.16em; text-transform: uppercase;
            border: 1px solid rgba(255,80,80,0.18); border-radius: 2rem;
            background: transparent; color: rgba(255,100,100,0.35);
            cursor: pointer; transition: all 0.25s ease;
            -webkit-tap-highlight-color: transparent;
        }
        .ls-reset-btn.confirming {
            border-color: rgba(255,80,80,0.7); color: rgba(255,120,120,0.9);
            background: rgba(255,50,50,0.08);
        }
        .ls-reset-btn:active { transform: scale(0.97); }

        /* Selected card */
        .ls-card.selected {
            border-color: rgba(168,247,244,0.5);
            background: rgba(168,247,244,0.07);
        }

        /* Sticky footer play bar */
        .ls-footer {
            flex-shrink: 0;
            display: flex; align-items: center; gap: 0.8rem;
            padding: 0.75rem 1rem;
            padding-bottom: max(0.75rem, env(safe-area-inset-bottom, 0px));
            border-top: 1px solid rgba(255,255,255,0.08);
            background: rgba(4,3,14,0.98);
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25,0.46,0.45,0.94);
        }
        .ls-footer.show { transform: translateY(0); }
        .ls-footer-info { flex: 1; min-width: 0; }
        .ls-footer-name {
            font-size: 0.72rem; font-weight: 700; color: rgba(255,255,255,0.9);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            margin-bottom: 0.2rem;
        }
        .ls-footer-meta {
            font-size: 0.56rem; color: rgba(255,255,255,0.4);
            letter-spacing: 0.06em;
        }
        .ls-play-btn {
            flex-shrink: 0;
            padding: 0.7rem 1.4rem; font-size: 0.68rem; font-weight: 700;
            letter-spacing: 0.14em; text-transform: uppercase;
            border: none; border-radius: 2rem; cursor: pointer;
            background: linear-gradient(120deg, #A8F7F4 0%, #B3C6FF 50%, #D4A7FF 100%);
            color: rgba(10,5,25,0.9);
            box-shadow: 0 2px 16px rgba(192,132,252,0.3);
            transition: all 0.2s ease;
            -webkit-tap-highlight-color: transparent;
        }
        .ls-play-btn:active { transform: scale(0.96); box-shadow: 0 1px 8px rgba(192,132,252,0.2); }
    </style>
</head>
<body>
    <div class="game-wrap">
        <div class="header">
            <div class="h-section left">
                <div class="h-val"><span id="h-orbs" style="font-variant-numeric:tabular-nums;">0</span><span id="h-orbs-total" style="opacity:0.2;font-size:0.55rem;font-variant-numeric:tabular-nums;"></span></div>
                <div class="h-lbl">Orbs Left</div>
            </div>
            <div class="h-section center">
                <div class="gs-logo" id="gs-logo">GEM SLAP</div>
            </div>
            <div class="h-section right" style="align-items:flex-end;">
                <button class="menu-btn" id="menu-btn">☰</button>
            </div>
        </div>
        <div class="prog-bar"><div class="prog-fill" id="prog-fill"></div></div>
        <canvas id="canvas"></canvas>
        <div class="footer">
            <div class="footer-timer" id="h-time">0.0s</div>
            <div class="beat-dot"></div><div class="beat-dot"></div><div class="beat-dot"></div><div class="beat-dot"></div>
            <button class="mute-btn" id="mute-btn">♫</button>
        </div>

        <!-- Intro menu button sits OUTSIDE start-screen so its clicks never bubble into it -->
        <button id="intro-menu-btn" style="position:absolute;top:max(1.1rem,env(safe-area-inset-top,1.1rem));right:1rem;z-index:510;padding:0.45rem 0.9rem;font-size:0.58rem;font-weight:700;letter-spacing:0.18em;text-transform:uppercase;border:1px solid rgba(255,255,255,0.18);border-radius:2rem;background:rgba(255,255,255,0.08);color:rgba(255,255,255,0.7);cursor:pointer;-webkit-tap-highlight-color:transparent;display:none;">☰ MENU</button>
        <div class="overlay" id="start-screen">
            <canvas id="intro-canvas"></canvas>
            <div class="intro-z">
                <div class="tut-hint" id="tut-hint"></div>
                <div class="intro-top">
                    <h1 class="title">GEM SLAP</h1>
                    <p class="tagline">tap orbs · shatter crystals</p>
                </div>
                <div class="intro-mid"></div>
                <div class="intro-bottom">
                    <div class="play-btn-wrap">
                        <button class="play-btn" id="play-btn">PLAY</button>
                    </div>
                    <div class="intro-tap-hint">or tap anywhere</div>
                </div>
            </div>
        </div>

        <!-- Achievement toast -->
        <div id="ach-toast">
            <div class="ach-toast-icon" id="ach-toast-icon">🔱</div>
            <div class="ach-toast-text">
                <div class="ach-toast-label">Achievement Unlocked</div>
                <div class="ach-toast-name" id="ach-toast-name">Hat Trick</div>
                <div class="ach-toast-desc" id="ach-toast-desc">Gold 3 levels in a row</div>
            </div>
        </div>

        <div class="end-float" id="end-float">
            <div class="ef-card" id="ef-card">
                <div class="ef-level" id="ef-level">Level 1</div>
                <div class="ef-pb" id="ef-pb">
                    <span class="ef-pb-val" id="ef-pb-val"></span>
                    <span class="ef-pb-badge" id="ef-pb-badge">NEW BEST</span>
                </div>
                <div class="ef-hero">
                    <div class="ef-tier-badge" id="ef-tier">GOLD</div>
                    <div class="ef-time" id="ef-time-big">0.0s</div>
                </div>
                <!-- Fail-state elements — hidden in win state via CSS -->
                <div class="ef-fail-crystals">
                    <div class="ef-fail-crys-val" id="ef-fail-crys-val">0/0</div>
                    <div class="ef-fail-crys-label">crystals shattered</div>
                </div>
                <div class="ef-fail-msg" id="ef-fail-msg"></div>
                <div class="ef-btns">
                    <button class="ef-btn-retry" id="ef-retry">Retry</button>
                    <button class="ef-btn-continue" id="ef-next">Continue</button>
                </div>
            </div>
        </div>

        <div class="overlay hidden" id="end-screen">
            <div class="end-card" id="end-card">
                <div class="ec-inner ec-level" id="ec-level">Level 1</div>
                <div class="ec-inner ec-score" id="ec-time-fail">0.0s</div>
                <div class="ec-inner ec-tier" id="ec-tier">CRYSTALS REMAIN</div>
                <div class="ec-inner ec-msg" id="ec-msg">The crystals hold.</div>
                <div class="ec-inner ec-row">
                    <div class="ec-cell"><div class="ec-val crystal" id="ec-crys">1/3</div><div class="ec-lbl">Crystals</div></div>
                    <div class="ec-cell"><div class="ec-val" id="ec-orbs">0/12</div><div class="ec-lbl">Orbs Used</div></div>
                </div>
                <div class="ec-inner ec-melody" id="ec-melody"></div>
                <div class="ec-inner bass-fav" id="bass-fav">
                    <span class="bass-name" id="bass-name">Classic Funk</span>
                    <span class="fav-heart">♥</span>
                </div>
                <div class="ec-inner ec-btns">
                    <button class="btn" id="btn-retry">Retry</button>
                    <button class="btn primary" id="btn-next" disabled>Continue</button>
                </div>
            </div>
        </div>
        <div class="ver">v65</div>
        <div class="offline-screen" id="offline-screen">
            <div class="offline-icon">✦</div>
            <div class="offline-msg">No connection<br>Level not available offline</div>
            <button class="offline-retry" id="offline-retry">Retry</button>
        </div>

        <!-- ── MENU ── -->
        <div class="menu-overlay" id="menu-overlay"></div>
        <div class="menu-panel" id="menu-panel">
            <div class="menu-header">
                <div class="menu-title">GEM SLAP</div>
                <button class="menu-close" id="menu-close">✕</button>
            </div>
            <div class="menu-tabs">
                <button class="menu-tab active" data-tab="progress">Progress</button>
                <button class="menu-tab" data-tab="stats">Stats</button>
                <button class="menu-tab" data-tab="achievements">Achievements</button>
            </div>
            <div class="menu-content">
                <!-- PROGRESS TAB -->
                <div class="menu-pane active" id="mpane-progress">
                    <div class="mpane-label">Level Reached</div>
                    <div class="mp-level-hero">
                        <div class="mp-level-num" id="mp-level-num">1</div>
                        <div class="mp-level-lbl">of 50</div>
                    </div>
                    <div class="mpane-label">Medal History</div>
                    <div id="mp-medal-grid"></div>
                </div>
                <!-- STATS TAB -->
                <div class="menu-pane" id="mpane-stats">
                    <div class="mpane-label">All Time</div>
                    <div class="stat-grid">
                        <div class="stat-cell"><div class="stat-val" id="ms-orbs">0</div><div class="stat-lbl">Orbs Hit</div></div>
                        <div class="stat-cell"><div class="stat-val" id="ms-time">0h</div><div class="stat-lbl">Play Time</div></div>
                        <div class="stat-cell"><div class="stat-val" id="ms-levels">0</div><div class="stat-lbl">Levels Cleared</div></div>
                        <div class="stat-cell"><div class="stat-val" id="ms-sessions">0</div><div class="stat-lbl">Sessions</div></div>
                    </div>
                    <div class="mpane-label">Personal Bests</div>
                    <div class="stat-grid">
                        <div class="stat-cell"><div class="stat-val" id="ms-gold">0</div><div class="stat-lbl">🥇 Gold</div></div>
                        <div class="stat-cell"><div class="stat-val" id="ms-silver">0</div><div class="stat-lbl">🥈 Silver</div></div>
                        <div class="stat-cell"><div class="stat-val" id="ms-bronze">0</div><div class="stat-lbl">🥉 Bronze</div></div>
                        <div class="stat-cell"><div class="stat-val" id="ms-best-time">—</div><div class="stat-lbl">Fastest Level</div></div>
                    </div>
                </div>
                <!-- ACHIEVEMENTS TAB -->
                <div class="menu-pane" id="mpane-achievements">
                    <div class="ach-list" id="ach-list"></div>
                </div>
            </div>
            <div class="menu-footer">
                <button class="ls-open-btn" id="menu-reset-btn">Level Select</button>
            </div>
        </div>

        <!-- ── LEVEL SELECT — inside game-wrap for correct positioning ── -->
        <div class="ls-overlay" id="ls-overlay"></div>
        <div class="ls-panel" id="ls-panel">
            <div class="ls-header">
                <div class="ls-title">Level Select</div>
                <button class="ls-close" id="ls-close">✕</button>
            </div>
            <div class="ls-scroll" id="ls-scroll"></div>
            <div class="ls-footer" id="ls-footer">
                <div class="ls-footer-info" id="ls-footer-info">
                    <div class="ls-footer-name" id="ls-footer-name"></div>
                    <div class="ls-footer-meta" id="ls-footer-meta"></div>
                </div>
                <button class="ls-play-btn" id="ls-play-btn">Play From This Level</button>
            </div>
        </div>
    </div>

    <!-- Engine: Audio, particles, draw functions, constants -->
    <script src="/static/engine.js"></script>

    <script>
    // ═══════════════════════════════════════
    //  PROGRESS — localStorage save/restore
    // ═══════════════════════════════════════
    const TOTAL_LEVELS = 50; // wrap back to level 1 after this
    const SAVE_KEY = 'gs_progress';

    function loadProgress() {
        try {
            const raw = localStorage.getItem(SAVE_KEY);
            return raw ? JSON.parse(raw) : {};
        } catch { return {}; }
    }

    function saveProgress(patch) {
        try {
            const current = loadProgress();
            const next = Object.assign(current, patch);
            localStorage.setItem(SAVE_KEY, JSON.stringify(next));
        } catch { /* storage unavailable — fail silently */ }
    }

    function getBestTime(level) {
        const p = loadProgress();
        return (p.bestTimes && p.bestTimes[level] != null) ? p.bestTimes[level] : null;
    }

    function setBestTime(level, time) {
        const p = loadProgress();
        const bestTimes = p.bestTimes || {};
        const bestTiers = p.bestTiers || {};
        const { tier } = getTier(time, state.targetTime);
        const isNew = bestTimes[level] == null || time < bestTimes[level];
        if (isNew) {
            bestTimes[level] = time;
            bestTiers[level] = tier;
            saveProgress({ bestTimes, bestTiers, highestLevel: Math.min(TOTAL_LEVELS, Math.max(p.highestLevel || 1, level)) });
        }
        return isNew;
    }

    // ═══════════════════════════════════════
    //  DOM & CANVAS SETUP
    // ═══════════════════════════════════════
    const $ = id => document.getElementById(id);
    const canvas = $('canvas');
    const ctx = canvas.getContext('2d');
    let gameWrap, canvasW = 400, canvasH = 600;

    const audio = new Audio();

    // ═══════════════════════════════════════
    //  GAME STATE
    // ═══════════════════════════════════════
    const state = {
        level: 1, orbs: [], allOrbs: [], bpm: 90, speed: 0.2, targetTime: 7, silverTime: null, bronzeTime: null,
        timing: { perfect: 100, great: 200, good: 350 },
        points: { perfect: 100, great: 60, good: 30, miss: 10 },
        score: 0, melody: [],
        startTime: 0, elapsed: 0, beatTime: 0, measureMs: 2000,
        started: false, playing: false, complete: false, levelCleared: false,
        countdown: 0, countdownStart: 0,
        visibleAtOnce: 4, totalOrbs: 12, orbsHit: 0, orbsSpawned: 0,
        bassStyle: 0, favBassStyle: null,
        targets: [], totalTargets: 0, targetsDestroyed: 0,
        targetDestroyRadius: 22, patternName: '',
        batchName: '', levelInSet: 1,
        freePlay: false, freePlayData: null,
        _reveal: null,
    };

    // ═══════════════════════════════════════
    //  PARTICLES & EFFECTS
    // ═══════════════════════════════════════
    let motes = [], bursts = [], crystalShards = [], energyMotes = [], crystalDust = [];
    // Cache beat-dot elements — queried once at init instead of every frame in draw()
    const _beatDots = Array.from(document.querySelectorAll('.beat-dot'));

    const SHOCK_RADIUS = 38;
    const SHOCK_STRENGTH = 10.0;
    const SHOCK_DECAY = 0.965;
    const SHOCK_MIN = 0.015;
    let shockwaves = [];
    let screenShake = { x: 0, y: 0, intensity: 0 };

    function initMotes() { motes = []; for (let i = 0; i < 35; i++) motes.push(new Mote(canvasW, canvasH)); }

    // ═══════════════════════════════════════
    //  RESPONSIVE LAYOUT
    // ═══════════════════════════════════════
    let orbScale = 1;

    function resize() {
        gameWrap = document.querySelector('.game-wrap'); if (!gameWrap) return;
        const wrapRect = gameWrap.getBoundingClientRect(), wrapW = wrapRect.width, wrapH = wrapRect.height;
        const safeTop = window.innerHeight !== document.documentElement.clientHeight ? Math.min(50, window.innerHeight - document.documentElement.clientHeight) : 0;
        // Read safe-area-inset-bottom at runtime — probe div with env() padding
        // gives us the real pixel value the browser computed for this device
        const _safeProbe = document.createElement('div');
        _safeProbe.style.cssText = 'position:fixed;bottom:0;height:0;padding-bottom:env(safe-area-inset-bottom,0px);visibility:hidden;pointer-events:none;';
        document.body.appendChild(_safeProbe);
        const safeBottom = parseFloat(getComputedStyle(_safeProbe).paddingBottom) || 0;
        document.body.removeChild(_safeProbe);
        const headerH = 52 + safeTop, progH = 2, footerH = 36 + safeBottom, canvasTop = headerH + progH;
        canvasW = Math.max(100, Math.floor(wrapW)); canvasH = Math.max(100, Math.floor(wrapH - canvasTop - footerH));
        canvas.style.top = canvasTop + 'px'; canvas.style.left = '0'; canvas.style.width = canvasW + 'px'; canvas.style.height = canvasH + 'px';
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = canvasW * dpr; canvas.height = canvasH * dpr; ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.scale(dpr, dpr);
        orbScale = Math.min(1, Math.min(canvasW, canvasH) / 350);
        // Invalidate caches that depend on canvas dimensions
        if (typeof _bgW !== 'undefined') { _bgW = 0; } // force bg rebuild
        if (typeof _orbPathCache !== 'undefined') _orbPathCache.clear();
        initMotes();
    }
    window.addEventListener('resize', () => setTimeout(resize, 50));
    window.addEventListener('orientationchange', () => setTimeout(resize, 200));
    if (window.visualViewport) window.visualViewport.addEventListener('resize', () => setTimeout(resize, 50));

    function getOrbAt(x, y) {
        for (let i = state.orbs.length - 1; i >= 0; i--) {
            const orb = state.orbs[i]; if (orb.hit) continue;
            const p = toScreen(orb), r = 32 * orb.size * orbScale;
            if (Math.hypot(x - p.x, y - p.y) < r * 1.1) return orb;
        }
        return null;
    }

    function getRating(orb, time) {
        const { dist } = getBrightness(orb, time);
        if (dist <= state.timing.perfect) return 'perfect';
        if (dist <= state.timing.great) return 'great';
        if (dist <= state.timing.good) return 'good';
        return 'miss';
    }

    // ═══════════════════════════════════════
    //  LEVEL CELEBRATION — "Confetti Burst"
    //
    //  Physics: x(t) = x0 + vx·t + ½ax·t²  +  flutter_amp·sin(ffreq·t + fph)
    //           y(t) = y0 + vy·t + ½g·t²
    //  The flutter term is the key — it makes pieces wobble laterally like
    //  real paper tumbling through air, not rigid computer squares.
    //  Rendered width oscillates with |cos(flipFreq·t)| so each piece
    //  visually "flips" between showing its face and its edge.
    //
    //  3 overlapping waves fired from two corner cannons + centre cannon.
    //  500 total particles. Never auto-deactivates — end card slides over it.
    // ═══════════════════════════════════════

    const _CB_PALETTE = [
        '#FF2840','#FF6B35','#F5C800','#28C858',
        '#18C8E0','#A855F7','#EC4899','#FB923C',
        '#8EEAF4','#B3C6FF','#D4A7FF','#FDE68A',
        '#6EE7B7','#FDA4AF','#A5F3FC','#FFD700',
        '#FFFFFF','#FFF0F5','#FFFDE7','#F0FFF4',
    ];

    function startShapeReveal() {
        // ── single wide-fan cannon at canvas centre-bottom ───────────────
        // One source, ~160° spread, large origin scatter → reads as one
        // unified explosion rather than three discrete columns.
        const GUN = { x: canvasW * 0.50, y: canvasH };

        // ── 3 staggered waves: big pop → echo → lingering shower ─────────
        const WAVES = [
            { count: 320, delayBase: 0.00, delayJitter: 0.08, speedMin: 380, speedMax: 680 },
            { count: 260, delayBase: 0.20, delayJitter: 0.10, speedMin: 320, speedMax: 580 },
            { count: 220, delayBase: 0.48, delayJitter: 0.14, speedMin: 260, speedMax: 500 },
        ];

        // Lower gravity → longer hang time, more leisurely rain-down
        const G = 300; // px/s²

        const particles = [];
        WAVES.forEach(wave => {
            for (let i = 0; i < wave.count; i++) {
                // Full 160° fan centred on straight-up, uniform distribution
                const angle = -Math.PI * 0.5 + (Math.random() - 0.5) * Math.PI * 1.78;
                const speed = wave.speedMin + Math.random() * (wave.speedMax - wave.speedMin);

                // Shape variety
                const roll = Math.random();
                let pw, ph, isCircle = false;
                if (roll < 0.52) {          // wide flat rectangle (most visible face)
                    pw = 7 + Math.random() * 7;
                    ph = 4 + Math.random() * 5;
                } else if (roll < 0.75) {   // narrow ribbon / streamer
                    pw = 2.5 + Math.random() * 2;
                    ph = 10  + Math.random() * 10;
                } else {                    // circle dot
                    pw = 4 + Math.random() * 4;
                    ph = pw;
                    isCircle = true;
                }

                particles.push({
                    // Wide origin scatter (±30% of canvas width) so the single
                    // source fans out naturally — no visible point-source clustering
                    x0: GUN.x + (Math.random() - 0.5) * canvasW * 0.60,
                    y0: GUN.y,
                    // velocity
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,   // negative = upward
                    // gravity — vary slightly per-particle so arcs differ
                    g:  G * (0.8 + Math.random() * 0.4),
                    // weak horizontal drift (air current)
                    ax: (Math.random() - 0.5) * 30,
                    // ── flutter: sinusoidal lateral wobble ──────────────────
                    // Amplitude 12–28px, frequency 2–5 Hz — creates the
                    // characteristic side-to-side tumble of real confetti
                    flutterAmp:  12 + Math.random() * 16,
                    flutterFreq: (2.0 + Math.random() * 3.0) * Math.PI * 2,
                    flutterPh:   Math.random() * Math.PI * 2,
                    // ── flip: piece rotates about its long axis ─────────────
                    // Rendered width oscillates as |cos(flipFreq·t + flipPh)|
                    // so it visually narrows to an edge then widens back to face
                    flipFreq: (1.5 + Math.random() * 3.5) * Math.PI * 2,
                    flipPh:   Math.random() * Math.PI * 2,
                    // visual
                    rot0:  Math.random() * Math.PI * 2,
                    drot:  (Math.random() - 0.5) * 12,   // rad/s — moderate spin
                    pw, ph, isCircle,
                    col:   _CB_PALETTE[Math.floor(Math.random() * _CB_PALETTE.length)],
                    // stagger within the wave window
                    delay: wave.delayBase + Math.random() * wave.delayJitter,
                });
            }
        });

        const centX  = state.targets.length
            ? state.targets.reduce((s, t) => s + (t.x / 100) * canvasW, 0) / state.targets.length
            : canvasW * 0.5;
        const bottom = state.targets.length
            ? Math.max(...state.targets.map(t => (t.y / 100) * canvasH))
            : canvasH * 0.65;
        const labelY = Math.min(canvasH - 52, bottom + 48);

        state._reveal = {
            active:    true,
            startTime: performance.now(),
            particles,
            centX,
            labelY,
            name:  state.patternName || '',
            batch: state.batchName ? `${state.batchName} · Level ${state.levelInSet}` : '',
        };
    }

    // ═══════════════════════════════════════
    //  MAIN RENDER LOOP
    // ═══════════════════════════════════════
    function draw() {
        state._lastDrawTime = performance.now();
        state._lastDrawWall = Date.now(); // wall clock — advances even when iOS freezes performance.now()
        const w = canvasW, h = canvasH, now = performance.now();

        ctx.save();
        if (screenShake.intensity > 0.1) {
            screenShake.x = (Math.random() - 0.5) * screenShake.intensity;
            screenShake.y = (Math.random() - 0.5) * screenShake.intensity;
            screenShake.intensity *= 0.88;
            ctx.translate(screenShake.x, screenShake.y);
        } else { screenShake.intensity = 0; }

        // Background — pre-rendered offscreen canvas, rebuilt only on resize
        if (!_bgCanvas || _bgW !== w || _bgH !== h) _buildBgCanvas(w, h);
        ctx.drawImage(_bgCanvas, -5, -5, w + 10, h + 10);

        if (state.playing && !state.complete) {
            if (!state.freePlay) state.elapsed = (now - state.startTime) / 1000;
            if (now % 100 < 20) updateHUD();
        }

        if (motes.length === 0 && w > 0) initMotes();
        motes.forEach(m => { m.w = w; m.h = h; m.update(); m.draw(ctx); });

        if (!state.started || state.complete) {
            const T = now / 1000;
            const demoCrystals = [
                { x: 30 + Math.sin(T * 0.2) * 5, y: 35 + Math.cos(T * 0.15) * 3, id: 0 },
                { x: 70 + Math.cos(T * 0.18) * 4, y: 55 + Math.sin(T * 0.22) * 4, id: 1 },
                { x: 50 + Math.sin(T * 0.25 + 2) * 6, y: 75 + Math.cos(T * 0.2 + 1) * 3, id: 2 },
            ];
            if (!state.started) {
                demoCrystals.forEach(dc => drawCrystal({ ...dc, alive: true, destroyTime: null }, now));
            }
        }

        state.targets.forEach(t => drawCrystal(t, now));

        // In-place dead removal — avoids allocating a new array every frame
        for (let i = bursts.length-1; i >= 0; i--)       { if (bursts[i].life <= 0)       bursts.splice(i,1); }
        bursts.forEach(b => { b.update(); b.draw(ctx); });
        for (let i = crystalShards.length-1; i >= 0; i--) { if (crystalShards[i].life <= 0) crystalShards.splice(i,1); }
        crystalShards.forEach(s => { s.update(); s.draw(ctx); });
        for (let i = energyMotes.length-1; i >= 0; i--)  { if (energyMotes[i].life <= 0)  energyMotes.splice(i,1); }
        energyMotes.forEach(e => { e.update(); e.draw(ctx); });
        for (let i = crystalDust.length-1; i >= 0; i--)  { if (crystalDust[i].life <= 0)  crystalDust.splice(i,1); }
        crystalDust.forEach(d => { d.update(); d.draw(ctx); });

        shockwaves = shockwaves.filter(sw => (now - sw.time) < 750);
        shockwaves.forEach(sw => {
            const age = now - sw.time, progress = age / 750;
            const ease = 1 - Math.pow(1 - progress, 3);
            const alpha = Math.pow(1 - progress, 1.5);
            const cx = (sw.x / 100) * canvasW, cy = (sw.y / 100) * canvasH;
            const avgDim = (canvasW + canvasH) / 2;
            const r = (sw.effectiveRadius / 100) * avgDim * ease;
            const srgb = hexToRgb(sw.color);
            if (r > 2) {
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.strokeStyle = rgba(srgb.r, srgb.g, srgb.b, alpha * 0.08);
                ctx.lineWidth = 14 * (1 - progress); ctx.stroke();
                ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(255,255,255,${alpha * 0.45 * (0.5 + sw.strength * 0.5)})`;
                ctx.lineWidth = 2.5 * (1 - progress * 0.5); ctx.stroke();
                ctx.beginPath(); ctx.arc(cx, cy, r * 0.9, 0, Math.PI * 2);
                ctx.strokeStyle = rgba(srgb.r, srgb.g, srgb.b, alpha * 0.3 * (0.5 + sw.strength * 0.5));
                ctx.lineWidth = 1.8 * (1 - progress * 0.5); ctx.stroke();
            }
            if (progress < 0.3) {
                const fillA = (1 - progress / 0.3) * 0.07 * (0.5 + sw.strength);
                const fillGrad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
                fillGrad.addColorStop(0, `rgba(255,255,255,${fillA * 0.6})`);
                fillGrad.addColorStop(0.5, rgba(srgb.r, srgb.g, srgb.b, fillA * 0.25));
                fillGrad.addColorStop(1, rgba(srgb.r, srgb.g, srgb.b, 0));
                ctx.fillStyle = fillGrad; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
            }
        });

        const orbsToDraw = [...state.orbs].sort((a, b) => a.y - b.y);
        orbsToDraw.forEach(orb => {
            try {
                if (orb.hit) {
                    if (orb.fade > 0.01) {
                        orb.fade -= 0.05;
                        const p = toScreen(orb), rgb = hexToRgb(orb.color), r = 32 * orb.size * orbScale;
                        const ring1R = r * (1 + (1 - orb.fade) * 1.2), ring2R = r * (1 + (1 - orb.fade) * 0.8);
                        ctx.beginPath(); ctx.arc(p.x, p.y, ring1R, 0, Math.PI * 2); ctx.strokeStyle = rgba(rgb.r, rgb.g, rgb.b, orb.fade * 0.4); ctx.lineWidth = 2; ctx.stroke();
                        ctx.beginPath(); ctx.arc(p.x, p.y, ring2R, 0, Math.PI * 2); ctx.strokeStyle = rgba(255, 255, 255, orb.fade * 0.3); ctx.lineWidth = 1.5; ctx.stroke();
                        if (orb.fade > 0.1) {
                            const fadeR = Math.max(1, r * orb.fade);
                            const fadeGrad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, fadeR);
                            fadeGrad.addColorStop(0, rgba(255, 255, 255, orb.fade * 0.4)); fadeGrad.addColorStop(0.5, rgba(rgb.r, rgb.g, rgb.b, orb.fade * 0.2)); fadeGrad.addColorStop(1, rgba(rgb.r, rgb.g, rgb.b, 0));
                            ctx.beginPath(); ctx.arc(p.x, p.y, fadeR, 0, Math.PI * 2); ctx.fillStyle = fadeGrad; ctx.fill();
                        }
                    }
                    return;
                }

                const driftMult = 0.25;
                orb.x += orb.driftX * driftMult;
                orb.y += orb.driftY * driftMult;
                if (orb.shockVx || orb.shockVy) {
                    orb.x += orb.shockVx; orb.y += orb.shockVy;
                    const transferRate = 0.04;
                    orb.driftX += (orb.shockVx / driftMult) * transferRate;
                    orb.driftY += (orb.shockVy / driftMult) * transferRate;
                    if (!orb._baseDriftSpeed) orb._baseDriftSpeed = Math.hypot(orb.driftX, orb.driftY);
                    const maxDrift = orb._baseDriftSpeed * 2.5;
                    const curDrift = Math.hypot(orb.driftX, orb.driftY);
                    if (curDrift > maxDrift) { orb.driftX = (orb.driftX / curDrift) * maxDrift; orb.driftY = (orb.driftY / curDrift) * maxDrift; }
                    orb.shockVx *= SHOCK_DECAY; orb.shockVy *= SHOCK_DECAY;
                    orb.shockEnergy = Math.hypot(orb.shockVx, orb.shockVy);
                    if (orb.shockEnergy < SHOCK_MIN) { orb.shockVx = 0; orb.shockVy = 0; orb.shockEnergy = 0; }
                }
                if (orb.x < 15 || orb.x > 85) { orb.driftX *= -1; if (orb.shockVx) orb.shockVx *= -0.5; orb.x = Math.max(15, Math.min(85, orb.x)); }
                if (orb.y < 15 || orb.y > 85) { orb.driftY *= -1; if (orb.shockVy) orb.shockVy *= -0.5; orb.y = Math.max(15, Math.min(85, orb.y)); }

                drawOrb(orb, now);
            } catch (e) { console.error('Orb draw error:', e); }
        });

        // ── Confetti Burst rendering ─────────────────────────────────────────
        // Rendered AFTER orbs intentionally — confetti flies over everything,
        // giving the screen a truly festive layered feel.
        const rev = state._reveal;
        if (rev && rev.active) {
            const revT = (performance.now() - rev.startTime) / 1000;

            rev.particles.forEach(p => {
                const pt = revT - p.delay;
                if (pt <= 0) return;

                // ── Flutter physics (fully analytical) ───────────────────────
                // Base projectile arc
                const bx = p.x0 + p.vx * pt + 0.5 * p.ax * pt * pt;
                const by = p.y0 + p.vy * pt + 0.5 * p.g  * pt * pt;
                // Flutter: sinusoidal wobble perpendicular to travel direction
                // As the piece falls the wobble becomes more prominent (gravity
                // slows vertical speed while horizontal flutter stays constant)
                const flutter = p.flutterAmp * Math.sin(p.flutterFreq * pt + p.flutterPh);
                // Apply flutter along the perpendicular of the velocity vector
                const spd = Math.hypot(p.vx, p.vy + p.g * pt) || 1;
                const nx  = -(p.vy + p.g * pt) / spd; // perpendicular x
                const ny  =   p.vx / spd;              // perpendicular y
                const x   = bx + flutter * nx;
                const y   = by + flutter * ny;

                // Cull permanently exited particles
                if (y > canvasH + 40) return;
                if (x < -80 || x > canvasW + 80) return;

                // Alpha — fade in fast, hold, then fade out gracefully
                // in the bottom 30% of canvas (organic "landing" effect)
                const fadeIn  = Math.min(1, pt / 0.15);
                const landA   = y > canvasH * 0.70
                    ? Math.max(0, 1 - (y - canvasH * 0.70) / (canvasH * 0.35))
                    : 1;
                const a = fadeIn * landA * 0.95;
                if (a < 0.018) return;

                // Rotation and flip
                const rot = p.rot0 + p.drot * pt;
                // Flip: rendered width oscillates as |cos(...)| — piece shows
                // face then edge then face, like real paper tumbling through air
                const flipW = p.isCircle
                    ? p.pw
                    : p.pw * Math.max(0.12, Math.abs(Math.cos(p.flipFreq * pt + p.flipPh)));

                const rgb = hexToRgb(p.col);
                ctx.save();
                ctx.globalAlpha = a;
                ctx.translate(x, y);
                ctx.rotate(rot);
                ctx.fillStyle = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
                if (p.isCircle) {
                    ctx.beginPath();
                    ctx.arc(0, 0, p.pw * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Use flipW for width — height stays constant
                    ctx.fillRect(-flipW * 0.5, -p.ph * 0.5, flipW, p.ph);
                }
                ctx.restore();
            });



            // Never hard-deactivate — end card slides over at 3.6s, and if the
            // player dismisses it quickly confetti is still falling beautifully.
            // Only cleared by loadLevel() which nulls state._reveal.
        }
        // ── End confetti burst ────────────────────────────────────────────────

        if (state.playing && state.measureMs > 0) {
            const beatMs = state.measureMs / 4;
            const since = ((now - state.beatTime) % state.measureMs + state.measureMs) % state.measureMs;
            const curBeat = Math.floor(since / beatMs), beatProgress = (since % beatMs) / beatMs;
            _beatDots.forEach((d, i) => d.classList.toggle('active', i === curBeat && beatProgress < 0.15));
        }

        ctx.restore();
        state.rafId = requestAnimationFrame(draw);
    }

    // ═══════════════════════════════════════
    //  SCORING
    // ═══════════════════════════════════════
    function calcScore() {
        const time = state.elapsed;
        const target = state.targetTime;
        return { time, target };
    }
    function getTier(time, target) {
        const silver = state.silverTime != null ? state.silverTime : target * 1.5;
        const bronze = state.bronzeTime != null ? state.bronzeTime : target * 2.0;
        if (time <= target) return { tier: 'gold',   text: '🥇' };
        if (time <= silver) return { tier: 'silver', text: '🥈' };
        if (time <= bronze) return { tier: 'bronze', text: '🥉' };
        return { tier: 'none', text: '—' };
    }

    function levelLabel(style = 'text') {
        const name = state.patternName || '';
        const num  = state.level || 1;
        if (style === 'header') {
            return name || `Level ${num}`;
        }
        if (style === 'end') {
            return name ? `Level ${num}: ${name}` : `Level ${num}`;
        }
        return name ? `Level ${num}: ${name}` : `Level ${num}`;
    }

    function updateHUD() {
        const { time, target } = calcScore();
        const { tier } = getTier(time, target);
        $('h-time').textContent = `${time.toFixed(1)}s`;
        $('h-time').style.color = tier === 'gold' ? '#F9DB6D' : tier === 'silver' ? '#4ECDC4' : tier === 'bronze' ? '#7EC8F0' : 'rgba(210,70,70,0.85)';
        const orbsLeft = state.totalOrbs - state.orbsHit;
        const crystalsLeft = state.totalTargets - state.targetsDestroyed;
        const orbEl = $('h-orbs');
        orbEl.textContent = orbsLeft;
        orbEl.className = '';
        if (crystalsLeft > 0) {
            if (orbsLeft <= crystalsLeft) orbEl.className = 'orbs-critical';
            else if (orbsLeft <= crystalsLeft + 2) orbEl.className = 'orbs-low';
        }

        $('prog-fill').style.width = `${Math.min(100, (state.targetsDestroyed / state.totalTargets) * 100)}%`;
    }

    function buildCrystalDots() {
        // crystal dots removed from header — progress bar tracks crystals
    }

    // ═══════════════════════════════════════
    //  INTERACTION — HIT ORB + CRYSTAL CHECK
    // ═══════════════════════════════════════
    function hitOrb(orb, x, y) {
        if (!orb || orb.hit || state.complete) return;
        const now = performance.now();
        const rating = getRating(orb, now);
        const pts = state.points[rating] || 10;

        orb.hit = true; orb.fade = 1; orb.hitTime = now;
        state.orbsHit++;
        state.melody.push({ note: orb.note, color: orb.color, rating });
        // Lifetime orb counter
        const _op = loadProgress();
        saveProgress({ totalOrbsHit: (_op.totalOrbsHit||0) + 1 });

        const vol = rating === 'perfect' ? 0.28 : rating === 'great' ? 0.24 : rating === 'good' ? 0.20 : 0.18;
        audio.tone(orb.note, 0.95, vol);

        const { brightness: hitBrightness } = getBrightness(orb, now);
        const hitSpawnAge = orb.spawnTime ? (now - orb.spawnTime) : 1000;
        const hitSpawnFade = Math.min(1, hitSpawnAge / 600);
        const hitSpawnEase = hitSpawnFade < 0.5 ? 4*hitSpawnFade*hitSpawnFade*hitSpawnFade : 1 - Math.pow(-2*hitSpawnFade+2,3)/2;
        const hitB = hitBrightness * hitSpawnEase;
        const hitSizeScale = 0.32 + hitB * 0.68;
        const orbVisualR = 40 * (orb.size || 1) * orbScale * hitSizeScale * hitSpawnEase;
        const crystalVisualR = 18 * orbScale * 1.1;
        const orbScreenX = (orb.x / 100) * canvasW;
        const orbScreenY = (orb.y / 100) * canvasH;

        let orbsAffected = 0, maxForce = 0;
        state.orbs.forEach(other => {
            if (other === orb || other.hit) return;
            const dx = other.x - orb.x, dy = other.y - orb.y;
            const dist = Math.hypot(dx, dy);
            if (dist < SHOCK_RADIUS && dist > 0.5) {
                const normalDist = dist / SHOCK_RADIUS;
                const force = SHOCK_STRENGTH * Math.pow(1 - normalDist, 2);
                const angle = Math.atan2(dy, dx);
                other.shockVx = (other.shockVx || 0) + Math.cos(angle) * force;
                other.shockVy = (other.shockVy || 0) + Math.sin(angle) * force;
                other.shockEnergy = Math.hypot(other.shockVx, other.shockVy);
                other.shockFlash = now;
                orbsAffected++; maxForce = Math.max(maxForce, force);
            }
        });

        const scatterStrength = Math.min(1, orbsAffected / 4);
        if (orbsAffected > 0) {
            shockwaves.push({ x: orb.x, y: orb.y, time: now, strength: scatterStrength, color: orb.color, effectiveRadius: SHOCK_RADIUS });
            screenShake.intensity = Math.max(screenShake.intensity, Math.min(8, orbsAffected * 1.8 + maxForce * 2));
            audio.shockwaveSound(scatterStrength);
        }

        let crystalsHitThisTurn = 0;
        state.targets.forEach(target => {
            if (!target.alive) return;
            const crystalScreenX = (target.x / 100) * canvasW;
            const crystalScreenY = (target.y / 100) * canvasH;
            const distPx = Math.hypot(crystalScreenX - orbScreenX, crystalScreenY - orbScreenY);
            if (distPx <= orbVisualR + crystalVisualR) {
                target.alive = false; target.destroyTime = now;
                state.targetsDestroyed++; crystalsHitThisTurn++;
                const palette = CRYSTAL_PALETTE[target.id % CRYSTAL_PALETTE.length];
                const sx = (target.x / 100) * canvasW, sy = (target.y / 100) * canvasH;
                const shardR = 18 * orbScale;
                const _pm = (typeof _isMobile !== 'undefined' && _isMobile);
                for (let i = 0; i < (_pm ? 6 : 10) + Math.floor(Math.random() * (_pm ? 4 : 6)); i++) crystalShards.push(new CrystalShard(sx, sy, palette, shardR));
                for (let i = 0; i < (_pm ? 8 : 15) + Math.floor(Math.random() * (_pm ? 6 : 10)); i++) energyMotes.push(new EnergyMote(sx, sy));
                for (let i = 0; i < (_pm ? 6 : 12) + Math.floor(Math.random() * (_pm ? 4 : 8)); i++) crystalDust.push(new CrystalDustP(sx, sy, palette));
                audio.crystalShatter(state.targetsDestroyed - 1, state.totalTargets);
            }
        });

        const avgDim = (canvasW + canvasH) / 2;
        const overlapRadiusPercent = ((orbVisualR + crystalVisualR) / avgDim) * 100;
        if (crystalsHitThisTurn > 0) {
            shockwaves.push({ x: orb.x, y: orb.y, time: now, strength: Math.min(1, crystalsHitThisTurn / 3), color: CRYSTAL_PALETTE[0].mid, effectiveRadius: overlapRadiusPercent });
            screenShake.intensity = Math.max(screenShake.intensity, crystalsHitThisTurn * 5);
            if (crystalsHitThisTurn >= 2) {
                showPop(x, y - 28, 'crystal-break', false, `×${crystalsHitThisTurn} SHATTER`);
                state._chainReactionEarned = true;
            }
        }

        const p = toScreen(orb);
        const baseCount = rating === 'perfect' ? 18 : rating === 'great' ? 10 : rating === 'good' ? 5 : 2;
        const scatterBonus = Math.min(14, orbsAffected * 3);
        for (let i = 0; i < baseCount + scatterBonus; i++) {
            const b = new Burst(p.x, p.y, orb.color);
            if (i >= baseCount) { b.size *= 1.3; const a = (i / scatterBonus) * Math.PI * 2; b.vx = Math.cos(a) * (3 + Math.random() * 2); b.vy = Math.sin(a) * (3 + Math.random() * 2); }
            bursts.push(b);
        }

        updateHUD();

        if (state.targetsDestroyed >= state.totalTargets && !state.freePlay) {
            state.levelCleared = true;
            state.freePlay = true;
            state.freePlayData = { ...calcScore() };
            if (state.orbsHit >= state.totalOrbs) state._lastCrystalUsed = true;
            if (state.elapsed <= 8) state._wreckingBallEarned = true;
            if ((state.totalOrbs - state.orbsHit) >= 4) state._orbsSpareEarned = true;
            showPop(canvasW / 2, canvasH / 2 + 52, 'crystal-clear', false, 'ALL SHATTERED');
            setTimeout(() => audio.crystalsClear(), 30);
            updateHUD();
            setTimeout(() => startShapeReveal(), 620);
            setTimeout(() => showFloatingEnd(), 1000);
            trySpawnNext();
            return;
        }
        if (!state.freePlay && state.orbsHit >= state.totalOrbs) {
            state.levelCleared = false;
            setTimeout(() => endLevel(false), 600);
            return;
        }
        trySpawnNext();
    }

    function showPop(x, y, rating, isScatter = false, customText = null) {
        const el = document.createElement('div');
        el.className = `pop ${rating}${isScatter ? ' scatter' : ''}`;
        el.textContent = customText || rating;
        el.style.left = x + 'px'; el.style.top = (y + 52) + 'px';
        document.querySelector('.game-wrap').appendChild(el);
        setTimeout(() => el.remove(), rating === 'crystal-clear' ? 800 : isScatter ? 500 : 450);
    }

    function handleInput(e) {
        e.preventDefault(); audio.unlock();
        if (!state.started) { startGame(); return; }
        if (state.complete || !state.playing) return;
        const rect = canvas.getBoundingClientRect();
        const touches = e.touches || [{ clientX: e.clientX, clientY: e.clientY }];
        for (const t of touches) {
            const x = t.clientX - rect.left, y = t.clientY - rect.top;
            const orb = getOrbAt(x, y);
            if (orb) hitOrb(orb, x, y);
        }
    }
    canvas.addEventListener('touchstart', handleInput, { passive: false });
    canvas.addEventListener('mousedown', handleInput);
    $('start-screen').addEventListener('click', () => { audio.unlock(); if (!state.started) startGame(); });
    $('play-btn').addEventListener('click', (e) => { e.stopPropagation(); audio.unlock(); if (!state.started) startGame(); });

    // ═══════════════════════════════════════
    //  INTRO SCENE ANIMATION
    // ═══════════════════════════════════════
    const introState = { running: true };

    function introLoop() {
        if (!introState.running) return;
        const now = performance.now();
        const ic = $('intro-canvas');
        const rect = ic.getBoundingClientRect();
        ic.width  = rect.width  * (window.devicePixelRatio || 1);
        ic.height = rect.height * (window.devicePixelRatio || 1);
        const ictx = ic.getContext('2d');
        ictx.scale((window.devicePixelRatio || 1), (window.devicePixelRatio || 1));
        const W = rect.width, H = rect.height;
        const T = now / 1000;

        // ── Background ─────────────────────────────────────────────
        ictx.fillStyle = '#030308'; ictx.fillRect(0, 0, W, H);

        // Subtle depth radial — very faint
        const depthG = ictx.createRadialGradient(W*0.5, H*0.48, 0, W*0.5, H*0.48, Math.max(W,H)*0.72);
        depthG.addColorStop(0,   'rgba(80,40,120,0.08)');
        depthG.addColorStop(0.5, 'rgba(40,20,80,0.04)');
        depthG.addColorStop(1,   'rgba(0,0,0,0)');
        ictx.fillStyle = depthG; ictx.fillRect(0, 0, W, H);

        // ── Ambient gem sparkles (drifting upward) ──────────────────
        const spkCols = [[127,244,240],[148,170,255],[192,132,252],[244,114,182],[255,209,82],[130,255,170],[255,160,120],[168,247,200],[220,130,255],[255,200,140],[100,220,255]];
        for (let i = 0; i < 11; i++) {
            const seed = i * 2.618;
            const bx = ((Math.sin(seed * 1.3) * 0.5 + 0.5) * 0.85 + 0.075) * W;
            const by = ((Math.cos(seed * 2.1) * 0.5 + 0.5) * 0.8  + 0.1)   * H;
            const py = ((by - T * (7 + (i % 4) * 2.5)) % H + H) % H;
            const px = bx + Math.sin(T * 0.4 + seed) * 7;
            const pa = (Math.sin(T * 0.55 + seed * 2.5) * 0.5 + 0.5) * 0.2;
            const ps = 1.4 + (i % 4) * 1.1;
            const [cr,cg,cb] = spkCols[i % spkCols.length];
            ictx.save(); ictx.translate(px, py); ictx.rotate(T * 0.22 + seed * 0.5);
            ictx.beginPath();
            ictx.moveTo(0, -ps*1.35); ictx.lineTo(ps*0.62, 0);
            ictx.lineTo(0,  ps*1.0 ); ictx.lineTo(-ps*0.62, 0);
            ictx.closePath();
            ictx.fillStyle = `rgba(${cr},${cg},${cb},${pa})`; ictx.fill();
            ictx.restore();
        }

        // ── Demo animation ─────────────────────────────────────────
        const cycle    = 4600;
        const t        = (now % cycle) / cycle;
        const sceneY   = H * 0.44;
        const crystalX = W * 0.64;
        const orbStartX = W * 0.1;
        const orbEndX   = crystalX - 6;
        const orbPhase  = Math.min(1, t / 0.48);
        const orbX      = orbStartX + (orbEndX - orbStartX) * easeInOutCubic(orbPhase);
        const orbAlpha  = t < 0.04 ? t / 0.04 : (t > 0.52 ? Math.max(0, 1 - (t - 0.52) / 0.08) : 1);
        const crystalAlive = t < 0.50;
        const shockPhase   = t > 0.50 ? (t - 0.50) / 0.22 : -1;

        // ── Crystal (white diamond gem) ─────────────────────────────
        if (crystalAlive) {
            const cR = Math.min(W, H) * 0.052;
            const R  = cR * (1 + Math.sin(T * 1.4) * 0.04);

            // Outer glow
            const glow = ictx.createRadialGradient(crystalX, sceneY, R*0.4, crystalX, sceneY, R*4.2);
            glow.addColorStop(0,   'rgba(212,167,255,0.16)');
            glow.addColorStop(0.35,'rgba(168,247,244,0.07)');
            glow.addColorStop(1,   'rgba(0,0,0,0)');
            ictx.fillStyle = glow; ictx.beginPath(); ictx.arc(crystalX, sceneY, R*4.2, 0, Math.PI*2); ictx.fill();

            // Diamond vertices
            const top    = { x: crystalX,          y: sceneY - R*1.3  };
            const right  = { x: crystalX + R*0.9,  y: sceneY - R*0.05 };
            const bottom = { x: crystalX,           y: sceneY + R*1.0  };
            const left   = { x: crystalX - R*0.9,  y: sceneY - R*0.05 };
            const crL    = { x: crystalX - R*0.33,  y: sceneY - R*0.55 };
            const crR    = { x: crystalX + R*0.33,  y: sceneY - R*0.55 };

            // Clipped fills
            ictx.save();
            ictx.beginPath();
            ictx.moveTo(top.x, top.y); ictx.lineTo(right.x, right.y);
            ictx.lineTo(bottom.x, bottom.y); ictx.lineTo(left.x, left.y);
            ictx.closePath(); ictx.clip();

            // White gradient base
            const baseG = ictx.createLinearGradient(crystalX, top.y, crystalX, bottom.y);
            baseG.addColorStop(0,   'rgba(255,255,255,0.92)');
            baseG.addColorStop(0.28,'rgba(228,238,255,0.78)');
            baseG.addColorStop(0.65,'rgba(198,218,255,0.58)');
            baseG.addColorStop(1,   'rgba(168,198,255,0.36)');
            ictx.fillStyle = baseG; ictx.fillRect(crystalX-R*1.1, top.y-2, R*2.2, bottom.y-top.y+4);

            // Prismatic shimmer (animated)
            [[127,244,240,0.22],[176,110,255,0.18],[255,167,212,0.14]].forEach(([r,g,b,a],i) => {
                const pa = T*0.22 + i*(Math.PI*2/3);
                const pg = ictx.createRadialGradient(
                    crystalX+Math.cos(pa)*R*0.55, sceneY+Math.sin(pa)*R*0.4, 0,
                    crystalX+Math.cos(pa)*R*0.55, sceneY+Math.sin(pa)*R*0.4, R*1.15);
                pg.addColorStop(0, `rgba(${r},${g},${b},${a})`); pg.addColorStop(1,'rgba(0,0,0,0)');
                ictx.fillStyle = pg; ictx.fillRect(crystalX-R*1.1, top.y-2, R*2.2, bottom.y-top.y+4);
            });

            // Top sparkle highlight
            const hl = ictx.createRadialGradient(crystalX, sceneY-R*0.58, 0, crystalX, sceneY-R*0.58, R*0.56);
            hl.addColorStop(0, `rgba(255,255,255,${0.78+Math.sin(T*1.9)*0.14})`);
            hl.addColorStop(0.55,'rgba(255,255,255,0.12)'); hl.addColorStop(1,'rgba(255,255,255,0)');
            ictx.fillStyle = hl; ictx.fillRect(crystalX-R*1.1, top.y-2, R*2.2, bottom.y-top.y+4);
            ictx.restore();

            // Outline
            ictx.beginPath();
            ictx.moveTo(top.x, top.y); ictx.lineTo(right.x, right.y);
            ictx.lineTo(bottom.x, bottom.y); ictx.lineTo(left.x, left.y);
            ictx.closePath();
            ictx.strokeStyle = 'rgba(255,255,255,0.72)'; ictx.lineWidth = 1.6; ictx.stroke();

            // Facet lines
            ictx.lineWidth = 0.75; ictx.strokeStyle = 'rgba(200,228,255,0.38)';
            [[top,crL],[top,crR],[crL,left],[crR,right],[crL,crR],
             [left,bottom],[right,bottom],[crL,bottom],[crR,bottom]
            ].forEach(([a,b]) => { ictx.beginPath(); ictx.moveTo(a.x,a.y); ictx.lineTo(b.x,b.y); ictx.stroke(); });
        }

        // ── Gem shard explosion ─────────────────────────────────────
        if (t > 0.50 && t < 0.93) {
            const sp = (t - 0.50) / 0.43;
            const shardCols = [[255,82,82],[82,255,143],[176,110,255],[82,194,255],[255,209,82],[255,82,196],[82,255,230]];
            for (let i = 0; i < 7; i++) {
                const angle = (i/7)*Math.PI*2 + i*0.38;
                const dist  = sp * Math.min(W,H) * 0.13 * (0.55 + (i%3)*0.22);
                const fx = crystalX + Math.cos(angle)*dist;
                const fy = sceneY   + Math.sin(angle)*dist + sp*sp*16;
                const fa = Math.max(0, 1 - sp*1.1) * 0.88;
                const fs = Math.min(W,H) * 0.013 * (1 - sp*0.58);
                const [sr,sg,sb] = shardCols[i];
                ictx.save(); ictx.translate(fx, fy); ictx.rotate(T*4.5 + i*1.15);
                ictx.beginPath();
                ictx.moveTo(0,-fs*1.4); ictx.lineTo(fs*0.68,0); ictx.lineTo(0,fs); ictx.lineTo(-fs*0.68,0);
                ictx.closePath();
                ictx.fillStyle = `rgba(${sr},${sg},${sb},${fa})`; ictx.fill();
                ictx.restore();
            }
        }

        // ── Orb (gem violet, travels toward crystal) ────────────────
        if (orbAlpha > 0.01) {
            const oR    = Math.min(W,H) * 0.043;
            const color = { r:160, g:80, b:255 };
            const ob    = 0.62 + Math.sin(T*2.2)*0.18;
            ictx.globalAlpha = orbAlpha;

            // Outer atmosphere
            const ag = ictx.createRadialGradient(orbX, sceneY, oR*0.3, orbX, sceneY, oR*2.8);
            ag.addColorStop(0, `rgba(${color.r},${color.g},${color.b},${0.22+ob*0.16})`);
            ag.addColorStop(0.5,`rgba(${color.r},${color.g},${color.b},0.05)`);
            ag.addColorStop(1,  `rgba(${color.r},${color.g},${color.b},0)`);
            ictx.fillStyle = ag; ictx.beginPath(); ictx.arc(orbX, sceneY, oR*2.8, 0, Math.PI*2); ictx.fill();

            // Wobbly body
            const bg = ictx.createRadialGradient(orbX+Math.sin(T)*oR*0.12, sceneY, oR*0.1, orbX, sceneY, oR);
            bg.addColorStop(0,   `rgba(240,210,255,${0.52+ob*0.35})`);
            bg.addColorStop(0.25,`rgba(200,140,255,${0.36+ob*0.28})`);
            bg.addColorStop(0.6, `rgba(${color.r},${color.g},${color.b},${0.2+ob*0.2})`);
            bg.addColorStop(1,   `rgba(${color.r},${color.g},${color.b},0.02)`);
            ictx.fillStyle = bg;
            ictx.beginPath();
            for (let i=0; i<=48; i++) {
                const a = (i/48)*Math.PI*2;
                const w = Math.sin(a*4+T*1.6)*0.06 + Math.sin(a*7-T*2.2)*0.04;
                const r = oR*(1+w);
                const ox = orbX+Math.cos(a)*r, oy = sceneY+Math.sin(a)*r;
                i===0 ? ictx.moveTo(ox,oy) : ictx.lineTo(ox,oy);
            }
            ictx.closePath(); ictx.fill();

            // Core highlight
            const cG = ictx.createRadialGradient(orbX, sceneY, 0, orbX, sceneY, oR*0.45);
            cG.addColorStop(0,  `rgba(255,255,255,${0.58+ob*0.28})`);
            cG.addColorStop(0.4,`rgba(230,200,255,${0.35+ob*0.18})`);
            cG.addColorStop(1,  'rgba(160,80,255,0)');
            ictx.fillStyle = cG; ictx.beginPath(); ictx.arc(orbX, sceneY, oR*0.45, 0, Math.PI*2); ictx.fill();

            ictx.globalAlpha = 1;
        }

        // ── Shockwave rings on impact ───────────────────────────────
        if (shockPhase > 0 && shockPhase < 1.4) {
            const ringCols = ['rgba(212,167,255','rgba(127,244,240','rgba(255,167,212'];
            for (let i=0; i<3; i++) {
                const rp = Math.max(0, shockPhase - i*0.1);
                if (rp <= 0 || rp > 1.2) continue;
                const rR = rp * Math.min(W,H) * 0.22;
                const rA = Math.max(0, 1-rp) * 0.42 * (1-i*0.24);
                ictx.beginPath(); ictx.arc(crystalX, sceneY, rR, 0, Math.PI*2);
                ictx.strokeStyle = `${ringCols[i]},${rA})`; ictx.lineWidth = 2.5-i*0.6; ictx.stroke();
            }
        }

        // ── Impact flash ────────────────────────────────────────────
        if (t > 0.50 && t < 0.60) {
            const fp = (t-0.50)/0.10, fa = (1-fp)*0.38;
            const fg = ictx.createRadialGradient(crystalX, sceneY, 0, crystalX, sceneY, Math.min(W,H)*0.13);
            fg.addColorStop(0,   `rgba(240,220,255,${fa})`);
            fg.addColorStop(0.4, `rgba(192,132,252,${fa*0.4})`);
            fg.addColorStop(1,   'rgba(100,60,200,0)');
            ictx.fillStyle = fg; ictx.beginPath(); ictx.arc(crystalX, sceneY, Math.min(W,H)*0.13, 0, Math.PI*2); ictx.fill();
        }

        // ── Aim ring (orb approaching crystal) ─────────────────────
        if (t > 0.30 && t < 0.50) {
            const tipP = (t-0.30)/0.20;
            const tipR = Math.min(W,H)*0.065*(0.5+tipP*0.5);
            const tipA = (Math.sin(tipP*Math.PI*3)*0.28+0.28)*Math.min(1,tipP*3);
            ictx.beginPath(); ictx.arc(orbX, sceneY, tipR, 0, Math.PI*2);
            ictx.strokeStyle = `rgba(192,140,255,${tipA})`; ictx.lineWidth = 1.5; ictx.stroke();
        }

        // ── Tut hint sync ───────────────────────────────────────────
        const hint = $('tut-hint');
        if (t > 0.22 && t < 0.50) {
            hint.textContent = 'tap the orb';
            hint.className   = 'tut-hint show tap-state';
        } else if (t > 0.52 && t < 0.80) {
            hint.textContent = 'smash the crystal';
            hint.className   = 'tut-hint show shatter-state';
        } else {
            hint.className = 'tut-hint';
        }

        requestAnimationFrame(introLoop);
    }

    introLoop();

    // ═══════════════════════════════════════
    //  GAME FLOW
    // ═══════════════════════════════════════
    // ── Level pre-fetch: cache next 20 levels in background ─────────────────
    function prefetchLevels(fromLevel) {
        if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) return;
        for (let i = 1; i <= 20; i++) {
            const n = fromLevel + i;
            // Stagger requests 250ms apart so we don't burst all 20 at once
            setTimeout(() => {
                const bassParam = state.favBassStyle !== null ? state.favBassStyle : (n - 1) % 15;
                const url = `/api/level/${n}/bass/${bassParam}`;
                navigator.serviceWorker.controller.postMessage({ type: 'CACHE_LEVEL', url });
            }, i * 250);
        }
    }

    async function loadLevel(n) {
        // Hide offline screen if showing
        $('offline-screen').classList.remove('show');

        try {
            state.orbs = []; state.allOrbs = [];
            state.playing = false; state.complete = false; state.freePlay = false; state.freePlayData = null;
            shockwaves = []; crystalShards = []; energyMotes = []; crystalDust = []; bursts = [];
            screenShake.intensity = 0;

            const bassParam = state.favBassStyle !== null ? state.favBassStyle : (n - 1) % 15;
            const url = `/api/level/${n}/bass/${bassParam}`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const data = await res.json();

            // If SW returned offline error JSON, treat as failure
            if (data.error === 'offline') throw new Error('offline');

            state.level = n;
            state.allOrbs = data.orbs.map(o => ({ ...o, hit: false, fade: 0, spawned: false }));
            state.orbs = [];
            state.speed = data.speed; state.targetTime = data.targetTime;
            state.timing = data.timing; state.points = data.points;
            state.visibleAtOnce = data.visibleAtOnce || 4; state.totalOrbs = data.totalOrbs || data.orbs.length;
            state.score = 0; state.melody = []; state.complete = false; state.levelCleared = false;
            state.elapsed = 0; state.orbsHit = 0; state.orbsSpawned = 0;
            state._chainReactionEarned = false; state._lastCrystalUsed = false;
            state._spawnStaggerPending = 0;
            state._wreckingBallEarned = false; state._orbsSpareEarned = false;
            state._reveal = null;
            state.bassStyle = bassParam;
            audio.setBassStyle(state.bassStyle);
            // Each track has its own BPM — get it from the engine's table
            state.bpm = audio.getBpm(state.bassStyle);
            state.measureMs = (60000 / state.bpm) * 4;

            state.targets = data.targets.map(t => ({ ...t, alive: true, destroyTime: null }));
            state.totalTargets = state.targets.length;
            state.targetsDestroyed = 0;
            // Gold = 5s + 1s per crystal; silver adds 1s/crystal; bronze adds another 1s/crystal
            state.targetTime = 5 + 1 * state.totalTargets;   // gold threshold
            state.silverTime = 5 + 2 * state.totalTargets;   // silver threshold
            state.bronzeTime = 5 + 3 * state.totalTargets;   // bronze threshold
            state.targetDestroyRadius = data.targetDestroyRadius;
            state.patternName = data.patternName || '';
            state.batchName = data.batchName || '';
            state.levelInSet = data.levelInSet || ((state.level - 1) % 10) + 1;
            // Store level name for level select
            if (state.patternName) {
                const _lnp = loadProgress();
                const levelNames = _lnp.levelNames || {};
                // Always overwrite — ensures renamed/reshuffled levels update correctly
                levelNames[n] = state.patternName; saveProgress({ levelNames });
            }

            $('h-time').textContent = '0.0s';
            $('h-time').style.color = 'rgba(255,255,255,0.5)';
            $('h-orbs').textContent = `${state.totalOrbs}`;
            $('h-orbs').className = '';
            $('h-orbs-total').textContent = `/${state.totalOrbs}`;
            $('prog-fill').style.width = '0%';
            buildCrystalDots();

            // Kick off background pre-fetch of next 20 levels
            prefetchLevels(n);

        } catch (err) {
            console.error('Failed to load level:', err);
            // Show offline screen with retry wired to re-attempt this level
            $('offline-screen').classList.add('show');
            $('offline-retry').onclick = async () => {
                $('offline-screen').classList.remove('show');
                await loadLevel(n);
                if (!$('offline-screen').classList.contains('show')) startCountdown();
            };
        }
    }

    function spawnInitialOrbs() {
        const toSpawn = state.allOrbs.filter(o => !o.spawned).slice(0, state.visibleAtOnce);
        toSpawn.forEach((orb, index) => { setTimeout(() => { spawnOrb(orb); }, index * 250); });
    }

    function spawnInitialOrbs() {
        const toSpawn = state.allOrbs.filter(o => !o.spawned).slice(0, state.visibleAtOnce);
        state._spawnStaggerPending = toSpawn.length;
        toSpawn.forEach((orb, index) => {
            setTimeout(() => {
                state._spawnStaggerPending = Math.max(0, (state._spawnStaggerPending || 0) - 1);
                spawnOrb(orb);
            }, index * 250);
        });
    }

    function spawnOrb(orb) {
        if (orb.spawned) return;
        let x, y, attempts = 0;
        do { x = 25 + Math.random() * 50; y = 25 + Math.random() * 50; attempts++; }
        while (attempts < 30 && state.orbs.some(o => !o.hit && Math.hypot(o.x - x, o.y - y) < 18));
        orb.x = x; orb.y = y;
        orb.spawned = true; orb.spawnTime = performance.now(); orb.fade = 0;
        orb.shockVx = 0; orb.shockVy = 0; orb.shockEnergy = 0; orb.shockFlash = null;
        orb._baseDriftSpeed = Math.hypot(orb.driftX, orb.driftY);
        state.orbs.push(orb); state.orbsSpawned++;
    }

    function trySpawnNext() {
        // Don't spawn if stagger is still filling up to visibleAtOnce — those slots
        // will arrive via setTimeout and we don't want to skip ahead of them
        const inFlight = state._spawnStaggerPending || 0;
        const liveOrbs = state.orbs.filter(o => !o.hit).length;
        if (liveOrbs + inFlight >= state.visibleAtOnce) return;
        const unspawned = state.allOrbs.filter(o => !o.spawned);
        if (unspawned.length > 0) spawnOrb(unspawned[0]);
    }

    async function startGame() {
        if (state.started) return;
        state.started = true;          // guard immediately — before any await
        introState.running = false;
        await audio.init(); resize();
        $('start-screen').classList.add('hidden');
        document.getElementById('intro-menu-btn').style.display = 'none';
        // Track session + day played
        const p = loadProgress();
        const today = new Date().toISOString().slice(0,10);
        const days = p.daysPlayed || [];
        if (!days.includes(today)) days.push(today);
        saveProgress({ sessions: (p.sessions||0) + 1, daysPlayed: days, sessionClears: 0, sessionGolds: 0 });
        // Resume from last selected/played level
        const resumeLevel = Math.max(1, p.resumeLevel || p.highestLevel || 1);
        await loadLevel(resumeLevel); startCountdown();
    }

    function startCountdown() {
        audio.stopBeat();
        // Increment generation so any stale setTimeout from a previous countdown
        // will see a mismatched generation and abort before calling spawnInitialOrbs
        // or audio.startBeat. This fires whenever level-select jumps happen mid-countdown.
        state._cdGen = (state._cdGen || 0) + 1;
        const myGen = state._cdGen;

        state.countdown = 3; state.countdownStart = performance.now(); state.playing = false;
        const countMs = 550;
        const totalMs = 3 * countMs;

        // Build the whole sequence wrapper once
        const wrap = document.createElement('div');
        wrap.className = 'cd-wrap';

        const panel = document.createElement('div');
        panel.className = 'cd-panel';

        const levelNum  = document.createElement('div');
        levelNum.className = 'cd-level-num';
        levelNum.textContent = `Level ${state.level || 1}`;
        panel.appendChild(levelNum);

        if (state.patternName) {
            const levelName = document.createElement('div');
            levelName.className = 'cd-level-name';
            levelName.textContent = state.patternName;
            panel.appendChild(levelName);
        }

        const numEl = document.createElement('div');
        numEl.className = 'cd-number c1';
        numEl.textContent = '3';

        wrap.appendChild(panel);
        wrap.appendChild(numEl);
        document.querySelector('.game-wrap').appendChild(wrap);

        // Tick through 3 → 2 → 1
        // Each tick replaces the number element to re-trigger CSS animation
        const colors = ['c1', 'c2', 'c3'];
        const labels = ['3', '2', '1'];
        [0, 1, 2].forEach(i => {
            setTimeout(() => {
                audio.countClick(i === 2);
                const old = wrap.querySelector('.cd-number');
                const n = document.createElement('div');
                n.className = `cd-number ${colors[i]}`;
                n.textContent = labels[i];
                if (old) wrap.replaceChild(n, old);
                else wrap.appendChild(n);
            }, i * countMs);
        });

        // Fade out wrapper then start play
        setTimeout(() => wrap.classList.add('fade-out'), totalMs - 380);
        setTimeout(() => {
            if (state._cdGen !== myGen) return; // stale — a newer countdown took over
            wrap.remove();
            state.countdown = 0; spawnInitialOrbs();
            const beatMs = (60000 / state.bpm);
            const leadIn = beatMs * 0.75;
            audio.startBeat(state.bpm, t => { state.beatTime = t + leadIn; state.startTime = t; });
            state.playing = true;
        }, totalMs + 80);
    }

    function showFloatingEnd() {
        const data = state.freePlayData;
        if (!data) return;
        const { time, target } = data;
        const { tier, text } = getTier(time, target);

        // Save progress + check for new best
        const isNewBest = setBestTime(state.level, time);
        const prevBest  = isNewBest ? null : getBestTime(state.level);
        // Lifetime: clears + play time + session clears + advance resume point
        const _lp = loadProgress();
        // On level 50 completion, resume wraps to 1; highestLevel caps at 50
        const _nextLvl = state.level >= TOTAL_LEVELS ? 1 : state.level + 1;
        const _resumePatch = { resumeLevel: _nextLvl };
        const _newHighest = Math.min(TOTAL_LEVELS, Math.max(_lp.highestLevel || 1, state.level + 1));
        if (_newHighest > (_lp.highestLevel || 1)) _resumePatch.highestLevel = _newHighest;

        // ── Achievement stat tracking ─────────────────────────────────────
        const _prevStreak    = _lp.goldStreak || 0;
        const _newStreak     = tier === 'gold' ? _prevStreak + 1 : 0;
        const _newTotalGolds = (tier === 'gold' ? (_lp.totalGolds||0) + 1 : (_lp.totalGolds||0));
        const _newSessGolds  = (tier === 'gold' ? (_lp.sessionGolds||0) + 1 : (_lp.sessionGolds||0));
        const _goldPerLevel  = { ...(_lp.goldPerLevel||{}) };
        if (tier === 'gold') _goldPerLevel[state.level] = Math.min(3, (_goldPerLevel[state.level]||0) + 1);
        const _achFlags = { ...(_lp.achFlags||{}) };
        if (state._chainReactionEarned) _achFlags.chainReaction = true;
        if (state._lastCrystalUsed)     _achFlags.lastCrystal   = true;
        if (state._wreckingBallEarned)  _achFlags.wreckingBall  = true;
        if (state._orbsSpareEarned)     _achFlags.orbsSpare     = true;

        saveProgress({
            totalClears: (_lp.totalClears||0) + 1,
            totalPlaySecs: (_lp.totalPlaySecs||0) + time,
            sessionClears: (_lp.sessionClears||0) + 1,
            goldStreak: _newStreak,
            totalGolds: _newTotalGolds,
            sessionGolds: _newSessGolds,
            goldPerLevel: _goldPerLevel,
            achFlags: _achFlags,
            ..._resumePatch,
        });
        // Check for newly unlocked achievements and show toast
        // _lp = snapshot BEFORE this save; loadProgress() = snapshot AFTER
        if (typeof checkAndToastAchievements === 'function') {
            checkAndToastAchievements(_lp, loadProgress());
        }

        const card = $('ef-card');
        card.className = `ef-card tier-${tier}`;
        $('ef-level').innerHTML = levelLabel('end');
        $('ef-tier').textContent = text;
        $('ef-tier').className = `ef-tier-badge c-${tier}`;

        // Personal best row
        const pbVal   = $('ef-pb-val');
        const pbBadge = $('ef-pb-badge');
        pbBadge.classList.remove('show');
        if (isNewBest && tier !== 'none') {
            pbVal.textContent = 'Personal best';
            // Delay badge slightly so it feels like a reveal
            setTimeout(() => pbBadge.classList.add('show'), 820);
        } else if (prevBest != null) {
            pbVal.textContent = `Best: ${prevBest.toFixed(1)}s`;
        } else {
            pbVal.textContent = '';
        }

        $('end-float').classList.add('show');

        const countStart = performance.now(); const dur = 600;
        function tick() {
            const p = Math.min(1, (performance.now() - countStart) / dur);
            const ease = 1 - Math.pow(1 - p, 3);
            $('ef-time-big').textContent = `${(time * ease).toFixed(1)}s`;
            if (p < 1) requestAnimationFrame(tick);
        }
        setTimeout(() => requestAnimationFrame(tick), 200);
    }

    function endLevel(cleared = true) {
        state.complete = true; state.playing = false;
        state.levelCleared = cleared;

        // Fail state: use the same ef-card drawer as the win state.
        // #end-screen is no longer used for the fail path.
        const broken  = state.targetsDestroyed;
        const total   = state.totalTargets;
        const ratio   = total > 0 ? broken / total : 0;

        // Contextual message — warm and forward-looking, never harsh
        let msg;
        if (broken === 0)          msg = 'Send those orbs flying and try again.';
        else if (ratio < 0.4)      msg = `${broken} crystal${broken > 1 ? 's' : ''} down. Keep going.`;
        else if (ratio < 0.75)     msg = 'Good progress — one more run should do it.';
        else if (ratio < 1.0)      msg = 'So close. The shape is almost there.';
        else                       msg = ''; // shouldn't reach here (that's a win)

        const efCard = $('ef-card');
        efCard.className = 'ef-card tier-fail';
        $('ef-level').innerHTML = levelLabel('end');
        $('ef-fail-crys-val').textContent = `${broken}/${total}`;
        $('ef-fail-msg').textContent = msg;
        audio.fail();
        $('end-float').classList.add('show');
    }

    function resetGameUI() {
        // Dismiss every overlay that could be open mid-game
        $('end-screen').classList.add('hidden');
        $('end-float').classList.remove('show');
        $('offline-screen').classList.remove('show');
        // Remove any in-progress countdown panel
        document.querySelectorAll('.cd-wrap').forEach(el => el.remove());
        state.freePlay = false;
        state.complete = false;
        // Fully kill level select — remove all classes so display:none takes effect
        // This is the only reliable way to guarantee zero pixels render
        const lsPanel   = document.getElementById('ls-panel');
        const lsFooter  = document.getElementById('ls-footer');
        const lsOverlay = document.getElementById('ls-overlay');
        if (lsPanel)   { lsPanel.classList.remove('show', 'animating'); lsPanel.style.transform = ''; }
        if (lsFooter)  { lsFooter.classList.remove('show'); lsFooter.style.transform = ''; }
        if (lsOverlay) { lsOverlay.classList.remove('show'); }
        // Clear scroll so no stale content on next open
        const scroll = document.getElementById('ls-scroll');
        if (scroll) scroll.innerHTML = '';
    }

    async function retry() {
        resetGameUI();
        audio.stopBeat();
        await loadLevel(state.level); startCountdown();
    }
    async function next() {
        resetGameUI();
        audio.stopBeat();
        // Wrap back to level 1 after the final level
        const nextLevel = state.level >= TOTAL_LEVELS ? 1 : state.level + 1;
        // Record unlock + update resume point
        // highestLevel caps at TOTAL_LEVELS (50 = game complete)
        const p = loadProgress();
        const _np = { resumeLevel: nextLevel };
        const newHighest = Math.min(TOTAL_LEVELS, Math.max(p.highestLevel || 1, state.level + 1));
        if (newHighest > (p.highestLevel || 1)) _np.highestLevel = newHighest;
        saveProgress(_np);
        await loadLevel(nextLevel); startCountdown();
    }

    $('btn-retry').addEventListener('click', () => { audio.unlock(); retry(); });
    $('btn-next').addEventListener('click', () => { audio.unlock(); next(); });
    $('ef-retry').addEventListener('click', () => { audio.unlock(); retry(); });
    $('ef-next').addEventListener('click', () => { audio.unlock(); next(); });
    $('mute-btn').addEventListener('click', () => {
        audio.beatOn = !audio.beatOn;
        $('mute-btn').classList.toggle('muted', !audio.beatOn);
        saveProgress({ muted: !audio.beatOn });
    });
    // Restore mute preference
    if (loadProgress().muted) {
        audio.beatOn = false;
        $('mute-btn').classList.add('muted');
    }

    $('bass-fav').addEventListener('click', () => {
        if (state.favBassStyle !== null) state.favBassStyle = null;
        else state.favBassStyle = state.bassStyle;
        $('bass-fav').className = `ec-inner bass-fav${state.favBassStyle !== null ? ' locked' : ''} show`;
    });

    // Menu, Level Select, Achievements → menu.js


    document.getElementById('intro-menu-btn').style.display = 'block';
    resize(); draw();

    // ═══════════════════════════════════════════════════════════════
    //  RENDER LOOP RESURRECTION
    //
    //  Problem: iOS Safari kills requestAnimationFrame after ~5 min
    //  of phone sleep. draw() stops running → blank canvas.
    //
    //  Three things go wrong simultaneously:
    //    1. rAF loop is dead                → canvas blank
    //    2. state.startTime is stale        → elapsed jumps, may false-complete
    //    3. state.beatTime is stale         → orb pulse phase is wrong
    //
    //  Root cause of the 5-min bug:
    //    The old code detected loop death via performance.now() gap.
    //    After a LONG sleep (5+ min), iOS freezes performance.now() during
    //    suspension. When the tab resumes, perf.now() has only advanced by
    //    ~16ms (one frame), so gap < 1500 and resurrection is skipped even
    //    though the rAF loop is actually dead.
    //
    //  Fix: use Date.now() (wall clock) for death detection — it always
    //  advances through iOS sleep. Keep performance.now() gap only for
    //  correcting animation timestamps (where monotonic time is needed).
    //  Also call resize() on resurrection: a long sleep can cause iOS to
    //  discard the canvas backing store sizing.
    // ═══════════════════════════════════════════════════════════════
    function _resurrectLoop() {
        if (document.hidden) return;

        // Use wall-clock gap to detect death — survives iOS perf.now() freeze
        const wallNow = Date.now();
        const wallGap = wallNow - (state._lastDrawWall || wallNow);
        if (wallGap < 1500) return;   // loop is alive, nothing to do

        // Performance.now() gap for correcting animation timestamps.
        // If iOS froze perf.now() during sleep, perfGap will be near 0
        // and these corrections are no-ops — correct, since the timestamps
        // are still valid relative to the resumed perf.now() clock.
        const perfNow = performance.now();
        const perfGap = perfNow - (state._lastDrawTime || perfNow);
        if (state.playing && !state.complete && !state.freePlay) {
            state.startTime += perfGap;
        }
        if (state.beatTime) state.beatTime += perfGap;

        // Resize before redrawing — long sleep can invalidate canvas sizing
        resize();

        // Cancel any ghost rAF ID and start a fresh loop
        cancelAnimationFrame(state.rafId);
        state.rafId = null;
        state._lastDrawTime = perfNow;
        state._lastDrawWall = wallNow;
        draw();
    }

    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) _resurrectLoop();
    });
    window.addEventListener('pageshow', _resurrectLoop);
    // touchstart as final safety net: catches hard lock/unlock on iOS
    // where visibilitychange and pageshow both misfire after long sleep
    document.addEventListener('touchstart', _resurrectLoop, { passive: true });


        </script>

    <!-- Menu, Level Select, Progress, Achievements -->
    <script src="/static/menu.js"></script>
    <script>
    // Register service worker
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/service-worker.js', { scope: '/' })
            .catch(err => console.warn('SW registration failed:', err));
    }
    </script>
</body>
</html>
